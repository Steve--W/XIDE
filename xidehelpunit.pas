(*
    Copyright (c) 2020  Steve Wright

    This unit is part of the XIDE project.

    This project is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

 **********************************************************************
 *)
unit XIDEHelpUnit;
{$ifndef JScript}
{$mode objfpc}{$H+}
{$endif}

interface

uses
  Classes, SysUtils, StringUtils, NodeUtils, XForm,
  {$ifndef JScript}
  Forms, Controls, Dialogs,LazsUtils, Events, {framView,}
  {$else}
  HTMLUtils,
  {$endif}
  WrapperPanel, XVBox, XHBox, XMemo, XButton,
  XLabel, XEditBox
  , EventsInterface, XHTMLText, XScrollBox, XHTMLEditor;

type

  { TXIDEHelpForm }

  TXIDEHelpForm = class(TXForm)
    HelpFormVBox1: TXVBox;
    HelpHTMLText: TXHTMLText;
    {$ifndef JScript}
    procedure FormActivate(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormResize(Sender: TObject);
    procedure FormShow(Sender: TObject);
//    procedure LoadNewText(Data: PtrInt);
    {$endif}
  private

  public
     procedure InitialiseonShow;
  end;


var
  XIDEHelpForm: TXIDEHelpForm;
  HelpFormRoot:TDataNode;

implementation
uses
  XObjectInsp;

{$R *.lfm}

const BaseHtml =
//'<h1 style="text-align: center;"><u>Overview</u></h1><h2 style="text-align: center;">&nbsp;(Helping people write simple apps that work "everywhere")</h2><h3>Purpose</h3><p>XIDE is a combined Development and Run Time Environment for Pascal and Python. It is designed to work in exactly the same way in&nbsp; Chrome,Linux,Windows or Android modes while minimising the required learning curve and installation overhead. The initial target applications are&nbsp;&nbsp;client side, "Line of business", embedded or exploratory apps where the focus is on custom functionality and rapid prototyping or cross platform working with cosmetic aspects of the design being a secondary consideration. It is not intended as a tool to develop web pages that are widely distributed to the general public.</p><h3>Installation</h3><p>In the browser, XIDE for Pascal is a single page web app with no dependencies. so installation is just a matter of loading that initial web page using an up to date copy of Chrome.&nbsp;</p><p>Python in XIDE is based on the Mozilla Pyodide project which brings a full data science stack to the browser, including NumPy, Pandas, Scipy, and Matplotlib. This requires additional HTML and JS files to be installed alongside the Main XIDE single page app. The version of the Pyodide files we provide can be hosted in a local directory, or on a web server so the same functionality is available both on-line and off-line with no further dependencies.</p><p>On the desktop, XIDE uses a local copy of Free Pascal and of&nbsp; Python, so these will need to be installed following the relevant instructions on their web sites. Installation of XIDE is then a matter of loading the XIDE.exe and using the main menu "Settings" option to point to the relevant Free Pascal and Python directories. The XIDE.exe file is compiled to run on either 32 or 64 bit desktops. To customise XIDE or exclusively target 64 bit machines, XIDE can be rebuilt from source using Lazarus.</p><h3>Functionality</h3><p>XIDE is designed to bring the power of Free Pascal and the convenience of&nbsp; Rapid Application Development (RAD) to the browser. It&nbsp; is a "Browser First" approach which delivers cross platform capability by replicating browser functionality on the desktop in native code. This allows the user to exploit the greater efficiency of compiled native code compared to interpreted browser environments as required. It also allows a single code base to support multiple different target environments for different user circumstances or different stages in a project.&nbsp;</p><p>The Python options in XIDE adds broader "Data Science" capabilities to the environment and&nbsp; allows the more interactive exploratory approach of Python to be exploited as required. See&nbsp;&nbsp;<a href="https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/">https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/</a></p><h3>Unified User Interface</h3><p>The browser supports a number of different standards as part of its user interface. These include HTML, CSS, SVG&nbsp;and GPU to cover page layout, style editing, vector graphics and graphics programming respectively. These all require their own conventions to be used when accessed directly from the browser and/or JavaScript.</p><p>XIDE unifies the user''s access to these different browser capabilities using a standardised Object Inspector / Drag and Drop approach for them all. For HTML and SVG this should appear seamless to the user with all the SVG containers and components accessed in an identical manner to HTML so requiring no further explanation than provided below for basic screen layout and editing.&nbsp;</p><h3>CSS Functionality</h3><p>CSS functionality is provided by supporting a style design tree in addition to the Code and UI design trees described below. As with the UI design tree, Style resources (new design rules, targets, properties and rule types ) are dragged from a resources tree and dropped on the relevant node of the style tree. The style tree also supports logical grouping of targets using "AND" and "OR" nodes.&nbsp; This speeds up and simplifies the CSS syntax generation considerably compared to direct text entry.</p><h3>GPU Code</h3><p>The GPU code capability would normally require a separate development environment and a specialised language to support development of code. XIDE encapsulates the complexities of WebGL by transpiling from (a subset of) pascal into WebGL / JavaScript code. WebGL has been chosen rather than say CUDA or OpenCL et. as WebGL is widely supported "out of the box"&nbsp; in most browsers and on most processor/GPU combinations. As such it minimises the&nbsp; installation and configuration needed in order to get XIDE running on a new system.</p><p>The Pascal code for the GPU is accessed as a property of a GPU Canvas component which has been dropped onto the User Interface layout screen and/or as a node on the Code designer tree.&nbsp; The Pascal GPU code editor follows the same edit/compile cycle as for user code in the rest of the system. The differences are that this is code for blocks of threads in parallel. The code describes a single instruction multiple data (SIMD) approach where all the threads run the same code with thread specific code referencing "this.thread.x" , "this.thread.y" and "this.thread.z"to reflect their position in the block of threads. Parameter names are declared using a Paramlist property of the GPU canvas component and their transfer and run time execution is controlled by system calls described below. (N.B. parameters need to be passed as arrays so even scalar parameters passed into the code need to be referenced as follows "myParam[0]" )</p><p>The Pascal GPU code can daisy chain kernels. (Set the TXGPUCanvas property NumKernels&gt;1) For each kernel in the chain its return value must be set to "MyValue". The next kernel in the chain can then read all the thread return values from the previous kernel by reading from "MyArray".The initial "MyArray" passed to the first kernel in the chain is set as a property ("InitStageData") of the GPU canvas and can have any x,y,z sizes as chosen by the user. The final&nbsp; &nbsp;kernel is the graphics display kernel where you set the r,g,b values as usual. The calculated data input to the graphics display kernel can also be accessed using either the "GetGPUStageArray" or "GetGPUStageArrayAsString" instructions;</p><p>Maths functions available in the GPU code are as follows:-</p><p></p><ul><li>abs(a) sign(a) trunc(a) ceil(a) max(a,b) min(a,b)</li><li>sin(a) cos(a) arcsin(a) arccos(a) arctan(a,b)</li><li>sqrt(a) power(a,b) ln(a) log10(a) log2(a)&nbsp;</li></ul><p></p><p>At this time, the subset of pascal functionality supported by&nbsp; the GPU is limited and no support is provided for the many sophisticated code optimisation options provided by specialist GPU programming environments. As such this capability is aimed at problems that can be made "embarrassingly parallel". See https://gpu.rocks/ for full details of the underlying JavaScript to webGL transpiler technology (N.B. Our releases lag theirs so some of the features described may not be available yet in our version)<br></p><h3>Limitations of coding for the GPU&nbsp;</h3><p>When coding in Pascal for the GPU, you should be aware that there are fundamental limitations on the constructs available. In particular:-</p><p></p><ul><li>All parameters passed into the GPU&nbsp; are real arrays (scalar parameters are real arrays of length one)<br></li><li>You can read from but not write to any of these array parameters</li><li>You cannot declare a local array</li><li>Each thread returns a single real value</li><li>You cannot communicate with any other thread (except by synchronising the results in a new kernel)</li><li>You cannot use a boolean type (use 0 or 1 instead)</li><li>You cannot use "Var" parameters in a function call</li><li>All function parameters must be a simple type</li><li>Nested function declarations do not follow normal (Pascal) scope rules</li><li>"While loops" should be used instead of "for loops" due to a limitation of our transpiler algorithm</li><li>Loops are unrolled so you MUST SET the "<span style="font-family: Verdana, Arial, sans-serif; font-size: 12px; white-space: nowrap;">MaxIterations"</span>&nbsp;parameter at a high enough value to reflect your algorithm''s requirements</li><li>The number of threads in each kernel are given by the KernelXDims,KernelYDims and Kernel ZDims properties of the GPU Canvas and these MUST BE SET either manually or programatically before activating the GPU.</li><li>The GPU is a Single Instruction Multiple Data machine so branching in a thread does not jump over the code in the path not taken,&nbsp; it idles in order to allow other threads to execute the code in that path if need be.&nbsp;</li><li>Debugging on the GPU is "primitive" the only way to do it when running on the hardware is to write out intermediate results&nbsp; to the thread output value for selected threads which you dedicate to providing diagnostic output. Alternatively a simple GPU emulator can help you&nbsp; develop the functional logic of your algorithm with the full debug capabilities of your development environment. However this will not warn you of circumstances where you have used a Pascal construct not available on the GPU.</li></ul><p>Having noted these limitations, and the need to become familiar with a new programming style for GPUs, It should be said that for many algorithms, particularly those that are naturally "Embarrassingly Parallel", the speed up available by using a GPU can often be between one and two orders of magnitude.</p><p></p><h3>Designing a User Interface<br></h3><p><b>Resource and Instance trees</b></p><p>XIDE uses a very simple paradigm. Essentially, it consists of three elements.</p><p></p><ol><li>&nbsp;A resources tree, showing the available widgets (visual and non visual)</li><li>&nbsp;A system design tree and object property inspector/editor</li><li>&nbsp;A layout panel showing a WYSIWYG version of the current page design.</li></ol><p></p> <p>The UI is built by pasting nodes from the resource tree to the system design tree.&nbsp;</p><p>Each node has object properties defined by a name/value pairs that can be edited using the object inspector or referenced and or updated by run time code.</p><p>Events are also available on each widget so that code can be attached to them using the built in code editor and compiler.&nbsp;</p><p>Each property can be bound to a selected data source at design time and code added to validate its status at run time. (Non visual components are dragged to the root node of the instance tree.)</p><p><b>Available widgets</b></p><p>The widgets listed in the resource tree include both UI and non visual components. The intention is that each widget is self documenting and that the set can be extended using third party contributions</p><p><b>Responsive Design</b></p><p>Web development has encouraged new and more flexible approaches to UI design. Unfortunately it has also led to an explosion of choice in this area. In practice this fragmentation creates new costs as well as benefits for our target user base. To counter this trend, XIDE only supports a simple responsive design layout paradigm.</p><p>In practice this consists of a Main page, Tab controls and Popups to define the constituent pages in a UI design. Horizontal and Vertical layout boxes (together with associated alignment properties) are then nested within these pages to control the final layout of components on the page.</p><p><b>Writing application code</b></p><p>XIDE uses an event driven model where event handlers written in Python and/or Pascal can be attached to pre defined events triggered by objects in the user interface. These procedures can be inspected and/or edited by using the object inspector to navigate to the required UI object then pressing the ellipsis button to the right of the required event in its events tab. This creates an entry for that event handler under the "Event Handlers"node in the code design tree. So once a handler has been added it can then also be navigated to by selecting it in the code designer and pressing the edit button.&nbsp;</p><p><b>Pascal Syntax</b></p><p>The Pascal syntax recognised by XIDE&nbsp;is that used by the Pas2JS variant of Free Pascal. (http://wiki.freepascal.org/pas2js). A detailed description of the supported syntax can be found here. (http://wiki.freepascal.org/pas2js#RTL)</p><p><b>Unit Structure</b></p><p>In addition to the event handler nodes, shared code can be written by adding units directly to the code design tree as "Pascal Units" These must have the "Interface"unit added to their uses clause in order to be able to access the XIDE API. In addition, they can access any of the standard set of PAS2JS run time library units. (http://wiki.freepascal.org/pas2js#RTL)&nbsp;</p><p>Functions and procedures&nbsp; in these "Pascal Unit" notes can be amended, added to or deleted by selecting the node on the code design tree and pressing the "Edit" button which will bring up the code editor screen as previously described for&nbsp; the event handler code.<br></p><p>After a Pascal unit has been compiled for the first time in a session,all the procedures and functions declared in it are displayed as its child nodes in the code design tree. Selecting one of these nodes and pressing the edit button below will navigate directly to that code. Alternatively, selecting a node and pressing "Code Search" will list all references to that function or procedure allowing you to navigate directly to the most relevant reference.</p><h3><b>Python&nbsp;</b></h3><p>The Python syntax used is version 3.8.&nbsp;</p><p>Python does not have a unit structure like Pascal, however blocks of Python code can be added to the Code Designer tree in the same way as Pascal units. The difference is that these will be run&nbsp; when entering run mode. They are executed in the order they occur on the Code Designer tree and can contain initialisation, declarations and / or&nbsp; any other valid executable Python Code.&nbsp;</p><p>To execute Python code elsewhere, such as in an event handler, then simply invoke the "RunPython(<i>......</i>)" procedure with the relevant python code as a string parameter,</p><h3>Using Python Interactively</h3><p>Console input and output boxes are supplied so that Python can be used interactively. On the desktop, the copy of Python being used is the version installed on the host machine, see the documentation for that system to review valid syntax, permissions etc. In the browser, the version of Python used is that supported by mozilla (see&nbsp;<a href="https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/">https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/</a>)</p><p><b>Accessing user interface objects at run time</b></p><p>XIDE is designed to be a cross platform rapid application development system. In order to do this it uses a text based system description tree (The System Design or instance tree) to reflect the state of a users program at all time. This is similar to the function of the Document Object Model (DOM) in standard web applications.</p> <p><b>Types of API Calls</b></p><p>In XIDE&nbsp;the instance tree describing a users project can be inspected manually using the Object Inspector. This allows the user to select any node on the tree and inspect and/or modify its properties or event handlers as required. The XIDE&nbsp;API allows the same actions to be available programmatically. This ability to generate events using code is particularly useful in automated testing, asynchronous call back functions, or multi threading applications. The functions available fall into eight types (and work in an identical manner in both Pascal and Python) viz:-</p><p></p><ul><li>&nbsp;Dialog boxes</li><li>&nbsp;Get and/or set a property value of a UI object</li><li>&nbsp;Save and load user selected data to the clipboard</li><li>&nbsp;copy or delete a UI component or move it to a new parent.</li><li>&nbsp;Add to, or replace, the event response for a UI object and/or trigger such an event artificially</li><li>&nbsp;Show or hide a popup form.</li><li>&nbsp;Show or hide a busy indicator.</li><li>&nbsp;get and set GPU parameters (integer,number and image)</li></ul><p></p><p>The detail syntax for these function calls is appended below. Note that unless explicitly stated, all values are either strings or string arrays.</p><p><b>Asynchronous Calls, Multi Threading and Initialization functions</b></p><p>Many web calls issue requests that need to wait for a response from a web service, database or other remote service provider. Similarly, when starting another thread in parallel, the main thread will often need to wait for such child threads to return the results of their work before it can proceed. XIDE&nbsp;allows main event handlers to specify a "initalisation"function. This is a block of code which issues all such requests prior to running the main event code when they have all finished executing. See below for the detail syntax of the available calls.</p><p>Note however that all such asynchronous calls first parameter is "e"the event context (automatically declared and populated by Xide, behind the scenes, for every XIDE&nbsp;event) from which they have been issued so they know where to return without requiring the user to enter complex boilerplate code.</p><p><b>List of&nbsp;XIDE&nbsp;specific API procedure and function calls</b></p> <p></p><ul><li>Procedure showMessage(TextMessage:string);</li><li>Procedure consoleLog(TextMessage:string);</li><li>Function&nbsp; &nbsp;confirm(TextMessage:string):boolean;</li><li>Function&nbsp; &nbsp;prompt(TextMessage,promptString:string):string;</li><li></li><li>Procedure RunPython(str:String);&nbsp; //<i> Executes the given Python script&nbsp;</i></li><li>Procedure debugStart;&nbsp; //<i>&nbsp;This is a browser only procedure (it can be present in desktop code but will be inactive there). In the browser it executes a Javascript "debugger;" statement which starts the native debug facility to allow single stepping, value inspection etc.</i></li><li>Procedure setPropertyValue(nodeName:String;propName:String;newValue:String);</li><li>Procedure setPropertyValueIndexed(nodeName:String;propName:String;newValue:TStringArray; x,y:integer);</li><li>Function&nbsp; &nbsp;getPropertyValue(nodeName:String;propName:String):string;</li><li>Function&nbsp; &nbsp;getPropertyValueIndexed(nodeName:String;propName:String; x,y,w,h:integer):TstringArray; <i>// When accessing array properties, "x" and "y" are the index positions for the top left position for the range to start. "w" and "h" are the width and height of the range. The type TStringArray is declared in pascal as&nbsp; "My string array = Array of String;"&nbsp; when accesed as a string it"s format is [["a","b","c"......"z"],["1","2","3"....."9"],....[...etc....]]</i></li><li>Procedure copyToClip(str:String);<i> //Place the string on the clipboard&nbsp;</i></li><li>Procedure copyFromClip(e); <i>// Fetch text from clipboard (note that this is an async operation so this line of code can only appear in an initialization tab of an event procedure. After this has executed the main event code tab can access the result using the parameter e.returnString )</i></li><li>Function&nbsp; loadTableFromExcelCopy(TableName,CopiedString:String); //<i> Populate the given TXTable component with a string in Excel format (eg. as copied from a spreadsheet)</i></li><li style="">procedure&nbsp; LoadTableFromNumArray(TableName,NumArray:T2DNumArray);&nbsp;<i> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Populate the given TXTable component from a 2D numeric array&nbsp;&nbsp;</i></li><li style="">function&nbsp; GetTableDataArray(TableName:String;SkipHeader:Boolean):String;&nbsp;<span style="font-style: italic;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Fetch the cells from the given TXTable component as a 2D string array&nbsp;&nbsp;</span></li><li>Procedure copycomponent(NodeToBeCopied,NewParentId,NewNodeID:string);</li><li>Function&nbsp; &nbsp;deletecomponent(NodeID:string):boolean; <i>// this returns true if the operation succeeds in deleteing the node (i.e. it existed and has been deleted)</i></li><li>Procedure moveComponent(nodeId,NewParentId:string);<i>// Re-parent the given XIDE component&nbsp;</i></li><li>Procedure doEvent(EventType,NodeId,myValue:string);<i> //Execute the event code for the given XIDE event type. To modify the response to an exiting event add an "EventTrapper" component to the system this will see the full event stream&nbsp; allowing you to filter this for the event of interest and code the appropriate additional action.&nbsp; Available information on each event consists of the following system defined variables. "e.EventType, e.NodeId, e.eventvalue : string;" to then continue to run the default event code, set "e.ContinueAfterTrappers = true;" at the end of the event handler&nbsp;</i></li><li>Procedure showXForm(XFormID:String; modal:Boolean);</li><li>Procedure closeXForm(XFormID:String);</li><li>Procedure showBusy;</li><li>Procedure hideBusy;</li><li>Procedure setGpuParamNumValue(GPUName,pName:String;pValue:number);</li><li>Procedure setGpuConstIntValue(GPUName,pName:String;pValue:integer);</li><li>Procedure setGpuParamImgValue(GPUName,pName:String;pValue:TImgArray);&nbsp;</li><li>Function&nbsp; &nbsp;getGpuPramNumValue(GPUName,pName:String):number;&nbsp;&nbsp;</li><li>Function&nbsp; &nbsp;getGpuConstIntValue(GPUName,pName:String):integer;&nbsp;&nbsp;</li><li>Function&nbsp; &nbsp;getGpuParamImgValue(GPUName,pName:String):TImgArray;&nbsp;&nbsp;</li><li>Function&nbsp; &nbsp;getGPUPixelArray(GPUName:String):T3DNumArray;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</li><li>Function&nbsp; &nbsp;getGPUPixelArrayAsString(GPUName:String):String;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</li><li>Function&nbsp; &nbsp;getGPUStageArray(GPUName:String):T3DNumArray;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</li><li>Function&nbsp; &nbsp;getGPUStageArrayAsString(GPUName:String):String;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</li></ul><p><b>App Development and Deployment</b></p><p>During the development phase of a project XIDE&nbsp;will usually be loaded in interactive app design mode where you can edit the user interface design and the code behind it. Here by default, the IDE re-loads the project you were last working on.&nbsp;</p><p>New projects can be started by clearing the current system or loading a previously saved system from the clipboard. This behaves the same in native host environments (Windows or Linux) as it does in Chrome or Android. At the end of this phase, you will sometimes want to deploy the developed app to end users without allowing access to the IDE. In this case, select the "System / Deploy" option from the main menu and this will generate a self contained HTML page implementing your application and the run time environment needed to execute it, but with the interactive IDE features disabled. You can now load this to a server of your choice, or email directly to your end user so they can run it from their file system.&nbsp;</p><p>Alternatively, if you wish to give them access to inspect and perhaps contribute to, or modify, the app, then distribute the blank XIDE app for their preferred platform (Chrome / Linux / Windows / Android) and use the "System / Save" option to generate a app definition file that they can load into it using the "System / Load" option on the main menu.&nbsp;</p><p><b>Debugging</b></p><p>When testing Pascal code you have written using XIDE, the PAS2JS compiler error messages will flag any source code syntax problems. If you click on one of these error messages this will position the cursor at the relevant character position in the line of code in the XIDE&nbsp;code editor. Run time errors will sometimes be trapped by error handlers built in to XIDE&nbsp;and generate a helpful error message. If this is not sufficient to uniquely identify the cause of the problem then "ctrl shift J" in Chrome will bring up the built in developer console which will hopefully provide the additional information you need to track down the problem. Alternatively, a break point can be set in the code by inserting a "DebugStart;" instruction that will start the native browser debug facility at that point.</p><h3>Implementation, Extensibility and Licensing<br></h3><p>XIDE is implemented using the Pas2JS dialect of the Object Pascal programming language. This is because it is efficient, easy to learn, and is available on a wide range of processor architectures.&nbsp;</p><p>Sometimes, as projects go through their life cycle, new more specialist requirements emerge. At this point the XIDE framework can be extended using project or platform specific custom components developed in Lazarus. Alternatively the HTML and JavaScript code generated by XIDE can be imported into a general-purpose web design tool stack to enable full enterprise level development.&nbsp;</p><p>XIDE is an open source project distributed using the same licence as Lazarus (GPL)</p><h3>Development Roadmap</h3><p>As an open source project, the future development of XIDE depends on how many collaborators choose to contribute to the project, and which aspects are most important to them.&nbsp;</p><p>The initial project has focused on functionality rather than style, and on the ability to operate as a fully self contained IDE with the minimum of dependencie and a simple learning curve.&nbsp;</p><p>As the project matures, it is hoped that new collaborators may add web connectivity, database access, comprehensive style support, support for other operating systems (eg IOS) or browsers other than Chrome.&nbsp;</p><h3>Compatibility</h3><p>In desktop mode, XIDE is designed to run on platforms supported by&nbsp; Lazarus, and optionally, the&nbsp; Chromium Embedded Framework and&nbsp; Python (i.e. most desktop platforms). If CEF or Python is not available then XIDE can still run but will then not support their specialist features.&nbsp;&nbsp;</p><p>In browser mode XIDE should run on any up to date HTML5 enabled browser. However as it is targeting closed user groups (where the browser can be specified)&nbsp; it is only tested on recent versions of Chrome.&nbsp;</p><p>Alternatively, Electron or Cordova and Crosswalk can be used to provide a hybrid implementation of XIDE. This gives full Web connectivity and CSS on a wide range of platforms but with a trade off in terms of size,speed and security.</p><p>Note that the Style Designer is only available on the Browser versions as it depends on CSS functionality.</p><p><br></p><p></p>';
//'<h1 style="text-align: center;"><u>Overview</u></h1><h2 style="text-align: center;">&nbsp;(Helping people write simple apps that work "everywhere")</h2><h3>Purpose</h3><p>XIDE is a combined Development and Run Time Environment for Pascal and Python. It is designed to work in exactly the same way in&nbsp; Chrome,Linux,Windows or Android modes while minimising the required learning curve and installation overhead. The initial target applications are&nbsp;&nbsp;client side, "Line of business", embedded or exploratory apps where the focus is on custom functionality and rapid prototyping or cross platform working with cosmetic aspects of the design being a secondary consideration. It is not intended as a tool to develop web pages that are widely distributed to the general public.</p><h3>Installation</h3><p>In the browser, XIDE for Pascal is a single page web app with no dependencies. so installation is just a matter of loading that initial web page using an up to date copy of Chrome.&nbsp;</p><p>Python in XIDE is based on the Mozilla Pyodide project which brings a full data science stack to the browser, including NumPy, Pandas, Scipy, and Matplotlib. This requires additional HTML and JS files to be installed alongside the Main XIDE single page app. The version of the Pyodide files we provide can be hosted in a local directory, or on a web server so the same functionality is available both on-line and off-line with no further dependencies.</p><p>On the desktop, XIDE uses a local copy of Free Pascal and of&nbsp; Python, so these will need to be installed following the relevant instructions on their web sites. Installation of XIDE is then a matter of loading the XIDE.exe and using the main menu "Settings" option to point to the relevant Free Pascal and Python directories. The XIDE.exe file is compiled to run on either 32 or 64 bit desktops. To customise XIDE or exclusively target 64 bit machines, XIDE can be rebuilt from source using Lazarus.</p><h3>Functionality</h3><p>XIDE is designed to bring the power of Free Pascal and the convenience of&nbsp; Rapid Application Development (RAD) to the browser. It&nbsp; is a "Browser First" approach which delivers cross platform capability by replicating browser functionality on the desktop in native code. This allows the user to exploit the greater efficiency of compiled native code compared to interpreted browser environments as required. It also allows a single code base to support multiple different target environments for different user circumstances or different stages in a project.&nbsp;</p><p>The Python options in XIDE adds broader "Data Science" capabilities to the environment and&nbsp; allows the more interactive exploratory approach of Python to be exploited as required. See&nbsp;&nbsp;<a href="https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/">https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/</a></p><p><br></p><h3>Unified User Interface<br></h3><p>The browser supports a number of different standards as part of its user interface. These include HTML, CSS, SVG&nbsp;and GPU to cover page layout, style editing, vector graphics and graphics programming respectively. These all require their own conventions to be used when accessed directly from the browser and/or JavaScript.<br></p><p>XIDE unifies the user''s access to these different browser capabilities using a standardised Object Inspector / Drag and Drop approach for them all. For HTML and SVG this should appear seamless to the user with all the SVG containers and components accessed in an identical manner to HTML so requiring no further explanation than provided below for basic screen layout and editing.&nbsp;</p><h3>CSS Functionality</h3><p>CSS functionality is provided by supporting a style design tree in addition to the Code and UI design trees described below. As with the UI design tree, Style resources (new design rules, targets, properties and rule types ) are dragged from a resources tree and dropped on the relevant node of the style tree. The style tree also supports logical grouping of targets using "AND" and "OR" nodes.&nbsp; This speeds up and simplifies the CSS syntax generation considerably compared to direct text entry.</p><h3>GPU Code</h3><p>The GPU code capability would normally require a separate development environment and a specialised language to support development of code. XIDE encapsulates the complexities of WebGL by transpiling from (a subset of) pascal into WebGL / JavaScript code. WebGL has been chosen rather than say CUDA or OpenCL et. as WebGL is widely supported "out of the box"&nbsp; in most browsers and on most processor/GPU combinations. As such it minimises the&nbsp; installation and configuration needed in order to get XIDE running on a new system.</p><p>The Pascal code for the GPU is accessed as a property of a GPU Canvas component which has been dropped onto the User Interface layout screen and/or as a node on the Code designer tree.&nbsp; The Pascal GPU code editor follows the same edit/compile cycle as for user code in the rest of the system. The differences are that this is code for blocks of threads in parallel. The code describes a single instruction multiple data (SIMD) approach where all the threads run the same code with thread specific code referencing "this.thread.x" , "this.thread.y" and "this.thread.z"to reflect their position in the block of threads. Parameter names are declared using a Paramlist property of the GPU canvas component and their transfer and run time execution is controlled by system calls described below. (N.B. parameters need to be passed as arrays so even scalar parameters passed into the code need to be referenced as follows "myParam[0]" )</p><p>The Pascal GPU code can daisy chain kernels. (Set the TXGPUCanvas property NumKernels&gt;1) For each kernel in the chain its return value must be set to "MyValue". The next kernel in the chain can then read all the thread return values from the previous kernel by reading from "MyArray".The initial "MyArray" passed to the first kernel in the chain is set as a property ("InitStageData") of the GPU canvas and can have any x,y,z sizes as chosen by the user. The final&nbsp; &nbsp;kernel is the graphics display kernel where you set the r,g,b values as usual. The calculated data input to the graphics display kernel can also be accessed using either the "GetGPUStageArray" or "GetGPUStageArrayAsString" instructions;</p><p>Maths functions available in the GPU code are as follows:-</p><p></p><ul><li>abs(a) sign(a) trunc(a) ceil(a) max(a,b) min(a,b)</li><li>sin(a) cos(a) arcsin(a) arccos(a) arctan(a,b)</li><li>sqrt(a) power(a,b) ln(a) log10(a) log2(a)&nbsp;</li></ul><p></p><p>At this time, the subset of pascal functionality supported by&nbsp; the GPU is limited and no support is provided for the many sophisticated code optimisation options provided by specialist GPU programming environments. As such this capability is aimed at problems that can be made "embarrassingly parallel". See https://gpu.rocks/ for full details of the underlying JavaScript to webGL transpiler technology (N.B. Our releases lag theirs so some of the features described may not be available yet in our version)<br></p><h3>Limitations of coding for the GPU&nbsp;</h3><p>When coding in Pascal for the GPU, you should be aware that there are fundamental limitations on the constructs available. In particular:-</p><p></p><ul><li>All parameters passed into the GPU&nbsp; are real arrays (scalar parameters are real arrays of length one)<br></li><li>You can read from but not write to any of these array parameters</li><li>You cannot declare a local array</li><li>Each thread returns a single real value</li><li>You cannot communicate with any other thread (except by synchronising the results in a new kernel)</li><li>You cannot use a boolean type (use 0 or 1 instead)</li><li>You cannot use "Var" parameters in a function call</li><li>All function parameters must be a simple type</li><li>Nested function declarations do not follow normal (Pascal) scope rules</li><li>"While loops" should be used instead of "for loops" due to a limitation of our transpiler algorithm</li><li>Loops are unrolled so you MUST SET the "<span style="font-family: Verdana, Arial, sans-serif; font-size: 12px; white-space: nowrap;">MaxIterations"</span>&nbsp;parameter at a high enough value to reflect your algorithm''s requirements</li><li>The number of threads in each kernel are given by the KernelXDims,KernelYDims and Kernel ZDims properties of the GPU Canvas and these MUST BE SET either manually or programatically before activating the GPU.</li><li>The GPU is a Single Instruction Multiple Data machine so branching in a thread does not jump over the code in the path not taken,&nbsp; it idles in order to allow other threads to execute the code in that path if need be.&nbsp;</li><li>Debugging on the GPU is "primitive" the only way to do it when running on the hardware is to write out intermediate results&nbsp; to the thread output value for selected threads which you dedicate to providing diagnostic output. Alternatively a simple GPU emulator can help you&nbsp; develop the functional logic of your algorithm with the full debug capabilities of your development environment. However this will not warn you of circumstances where you have used a Pascal construct not available on the GPU.</li></ul><p>Having noted these limitations, and the need to become familiar with a new programming style for GPUs, It should be said that for many algorithms, particularly those that are naturally "Embarrassingly Parallel", the speed up available by using a GPU can often be between one and two orders of magnitude.</p><p></p><h3>Designing a User Interface<br></h3><p><b>Resource and Instance trees</b></p><p>XIDE uses a very simple paradigm. Essentially, it consists of three elements.</p><p></p><ol><li>&nbsp;A resources tree, showing the available widgets (visual and non visual)</li><li>&nbsp;A system design tree and object property inspector/editor</li><li>&nbsp;A layout panel showing a WYSIWYG version of the current page design.</li></ol><p></p> <p>The UI is built by pasting nodes from the resource tree to the system design tree.&nbsp;</p><p>Each node has object properties defined by a name/value pairs that can be edited using the object inspector or referenced and or updated by run time code.</p><p>Events are also available on each widget so that code can be attached to them using the built in code editor and compiler.&nbsp;</p><p>Each property can be bound to a selected data source at design time and code added to validate its status at run time. (Non visual components are dragged to the root node of the instance tree.)</p><p><b>Available widgets</b></p><p>The widgets listed in the resource tree include both UI and non visual components. The intention is that each widget is self documenting and that the set can be extended using third party contributions</p><p><b>Responsive Design</b></p><p>Web development has encouraged new and more flexible approaches to UI design. Unfortunately it has also led to an explosion of choice in this area. In practice this fragmentation creates new costs as well as benefits for our target user base. To counter this trend, XIDE only supports a simple responsive design layout paradigm.</p><p>In practice this consists of a Main page, Tab controls and Popups to define the constituent pages in a UI design. Horizontal and Vertical layout boxes (together with associated alignment properties) are then nested within these pages to control the final layout of components on the page.</p><p><b>Writing application code</b></p><p>XIDE uses an event driven model where event handlers written in Python and/or Pascal can be attached to pre defined events triggered by objects in the user interface. These procedures can be inspected and/or edited by using the object inspector to navigate to the required UI object then pressing the ellipsis button to the right of the required event in its events tab. This creates an entry for that event handler under the "Event Handlers"node in the code design tree. So once a handler has been added it can then also be navigated to by selecting it in the code designer and pressing the edit button.&nbsp;</p><p><b>Pascal Syntax</b></p><p>The Pascal syntax recognised by XIDE&nbsp;is that used by the Pas2JS variant of Free Pascal. (http://wiki.freepascal.org/pas2js). A detailed description of the supported syntax can be found here. (http://wiki.freepascal.org/pas2js#RTL)</p><p><b>Unit Structure</b></p><p>In addition to the event handler nodes, shared code can be written by adding units directly to the code design tree as "Pascal Units" These must have the "Interface"unit added to their uses clause in order to be able to access the XIDE API. In addition, they can access any of the standard set of PAS2JS run time library units. (http://wiki.freepascal.org/pas2js#RTL)&nbsp;</p><p>Functions and procedures&nbsp; in these "Pascal Unit" notes can be amended, added to or deleted by selecting the node on the code design tree and pressing the "Edit" button which will bring up the code editor screen as previously described for&nbsp; the event handler code.<br></p><p>After a Pascal unit has been compiled for the first time in a session,all the procedures and functions declared in it are displayed as its child nodes in the code design tree. Selecting one of these nodes and pressing the edit button below will navigate directly to that code. Alternatively, selecting a node and pressing "Code Search" will list all references to that function or procedure allowing you to navigate directly to the most relevant reference.</p><h3><b>Python&nbsp;</b></h3><p>The Python syntax used is version 3.8.&nbsp;</p><p>Python does not have a unit structure like Pascal, however blocks of Python code can be added to the Code Designer tree in the same way as Pascal units. The difference is that these will be run&nbsp; when entering run mode. They are executed in the order they occur on the Code Designer tree and can contain initialisation, declarations and / or&nbsp; any other valid executable Python Code.&nbsp;</p><p>To execute Python code elsewhere, such as in an event handler, then simply invoke the "RunPython(<i>......</i>)" procedure with the relevant python code as a string parameter,</p><h3>Using Python Interactively</h3><p>Console input and output boxes are supplied so that Python can be used interactively. On the desktop, the copy of Python being used is the version installed on the host machine, see the documentation for that system to review valid syntax, permissions etc. In the browser, the version of Python used is that supported by mozilla (see&nbsp;<a href="https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/">https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/</a>)</p><p><b>Accessing user interface objects at run time</b></p><p>XIDE is designed to be a cross platform rapid application development system. In order to do this it uses a text based system description tree (The System Design or instance tree) to reflect the state of a users program at all time. This is similar to the function of the Document Object Model (DOM) in standard web applications.</p> <p><b>Types of API Calls</b></p><p>In XIDE&nbsp;the instance tree describing a users project can be inspected manually using the Object Inspector. This allows the user to select any node on the tree and inspect and/or modify its properties or event handlers as required. The XIDE&nbsp;API allows the same actions to be available programmatically. This ability to generate events using code is particularly useful in automated testing, asynchronous call back functions, or multi threading applications. The functions available fall into eight types (and work in an identical manner in both Pascal and Python) viz:-</p><p></p><ul><li>&nbsp;Dialog boxes</li><li>&nbsp;Get and/or set a property value of a UI object</li><li>&nbsp;Save and load user selected data to the clipboard</li><li>&nbsp;copy or delete a UI component or move it to a new parent.</li><li>&nbsp;Add to, or replace, the event response for a UI object and/or trigger such an event artificially</li><li>&nbsp;Show or hide a popup form.</li><li>&nbsp;Show or hide a busy indicator.</li><li>&nbsp;get and set GPU parameters (integer,number and image)</li></ul><p></p><p>The detail syntax for these function calls is appended below. Note that unless explicitly stated, all values are either strings or string arrays.</p><p><b>Asynchronous Calls, Multi Threading and Initialization functions</b></p><p>Many web calls issue requests that need to wait for a response from a web service, database or other remote service provider. Similarly, when starting another thread in parallel, the main thread will often need to wait for such child threads to return the results of their work before it can proceed. XIDE&nbsp;allows main event handlers to specify a "initalisation"function. This is a block of code which issues all such requests prior to running the main event code when they have all finished executing. See below for the detail syntax of the available calls.</p><p>Note however that all such asynchronous calls first parameter is "e"the event context (automatically declared and populated by Xide, behind the scenes, for every XIDE&nbsp;event) from which they have been issued so they know where to return without requiring the user to enter complex boilerplate code.</p><h3><b><u>List of&nbsp;XIDE&nbsp;specific API procedure and function calls</u></b></h3> <p></p><h3><u>General Functions</u></h3><ul><li>procedure SetPropertyValue(nodeName,propName,newValue:String);&nbsp;&nbsp;&nbsp; &nbsp;<font color="#0000ff">set a component property (string value)&nbsp;&nbsp;</font></li><li>function&nbsp; GetPropertyValue(nodeName,propName:String);&nbsp;<font color="#0000ff">&nbsp; &nbsp;returns a component property value (as string)&nbsp;</font></li><li>procedure SetPropertyValueIndexed(nodeName,propName:String;newValue:TStringArray; x,y:integer);&nbsp;&nbsp; &nbsp;<font color="#0000ff">set a portion of a component array property</font>&nbsp;&nbsp;</li><li>procedure CopyToClip(str:String);&nbsp;&nbsp;<font color="#0000ff">&nbsp;copies the given string to the clipboard&nbsp;</font></li><li>function&nbsp; CopyFromClip(e:TEventStatus):String;&nbsp;&nbsp;&nbsp;<font color="#0000ff">CopyFromClip is an async function (required for browser use), so it must be coded in the&nbsp;&nbsp;''Init'' section of an event handler. The result here is a blank string.&nbsp;&nbsp;&nbsp;The clipboard string is held in e.ReturnString, which cn be picked up in the&nbsp;&nbsp;&nbsp; &nbsp;''Main'' section of the event handler.</font></li><li>procedure ShowXForm(XFormID:String; modal:Boolean);&nbsp;&nbsp;<font color="#0000ff">&nbsp;opens a TXForm. [note:''modal=false'' currently only effective on desktop]&nbsp;</font></li><li>procedure CloseXForm(XFormID:String);&nbsp;&nbsp;<font color="#0000ff">&nbsp;closes a TXForm.&nbsp;&nbsp;</font></li><li>procedure DoEvent(EventType,NodeId,myValue:String);&nbsp;<font color="#0000ff"> executes the event handler defined for the given event type and component.&nbsp;</font></li><li>procedure MoveComponent(nodeId:string;NewParentId:string);&nbsp;&nbsp;<font color="#0000ff">re-parents the given UI component&nbsp;</font></li><li>procedure CopyComponent(nodeId,NewParentId,NewName:string);&nbsp;<font color="#0000ff">copies the given UI component and places the clone under the given parent&nbsp;</font></li><li>function&nbsp; DeleteComponent(nodeId:string;ShowNotFoundMsg:Boolean=true):Boolean;&nbsp;&nbsp; <font color="#0000ff">&nbsp;deletes the given UI component. Returns false if not done.&nbsp;</font></li><li>function&nbsp; UserSystemAsString():String;&nbsp; <font color="#0000ff">Returns the string representation of the current user system (can be imported to XIDE via System&gt;Load)&nbsp;&nbsp;</font></li><li>function&nbsp; LoadUserSystemString(SystemString:String);&nbsp;&nbsp;<font color="#0000ff">Imports a new user system to the XIDE framework (can only be done in ''Design'' mode)&nbsp;</font></li><li>procedure ShowBusy(e:TEventStatus);&nbsp;&nbsp;<font color="#0000ff">Shows the busy cursor&nbsp;ShowBusy is an async function (required for browser use), so it must be coded in the&nbsp; ''Init'' section of an event handler.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></li><li>procedure HideBusy;&nbsp; &nbsp;<font color="#0000ff">Hides the busy cursor&nbsp;</font>&nbsp;</li><li>procedure ProcessMessages;&nbsp; <font color="#0000ff">&nbsp;Functional in Desktop execution only.&nbsp; Executes a pascal Application.ProcessMessages statement.&nbsp;&nbsp;</font></li><li>procedure DebugStart;&nbsp; &nbsp;<font color="#0000ff">Functional in Browser execution only.&nbsp; Executes a Javascript ''debugger;'' statement - starts the native browser debug facility.&nbsp;&nbsp;</font></li><li>procedure RunPython(str:String);&nbsp;<font color="#0000ff">&nbsp;Executes the given Python script&nbsp;</font></li></ul></div><div contenteditable="true"><ul></ul><h3><u>Messages and Dialogs</u></h3><ul><li>procedure ShowMessage(msg:String);&nbsp; <font color="#0000ff">&nbsp;displays a popup alert&nbsp;</font></li><li>function&nbsp; Confirm(TextMessage:string):boolean;&nbsp;&nbsp;<font color="#0000ff">displays a confirmation alert; returns true/false&nbsp;</font></li><li>function&nbsp; Prompt(TextMessage,promptString:string):string;&nbsp;&nbsp;&nbsp;<font color="#0000ff">displays an input box; returns user-entered string&nbsp;</font></li><li>procedure ConsoleLog(txt:String);&nbsp; <font color="#0000ff">Writes a debug message to the console log&nbsp;&nbsp;</font></li></ul><ul></ul><h3><u>TXTable Functions</u></h3><ul><li>procedure&nbsp; LoadTableFromExcelCopy(TableName,CopiedString:String);&nbsp;&nbsp;<font color="#0000ff">Populate the given TXTable component with a string in Excel format (eg. as copied from a spreadsheet)&nbsp;&nbsp;</font></li><li>procedure&nbsp; LoadTableFromNumArray(TableName,NumArray:T2DNumArray);&nbsp;&nbsp;<font color="#0000ff">Populate the given TXTable component from a 2D numeric array&nbsp;&nbsp;</font></li><li>function&nbsp; GetTableDataArray(TableName:String;SkipHeader:Boolean):T2DStringArray;&nbsp;&nbsp;<font color="#0000ff">&nbsp;Fetch the cells from the given TXTable component as a 2D string array&nbsp;&nbsp;</font></li><li>function&nbsp; Array2DToString(arr:T2DNumArray):String;&nbsp; <font color="#0000ff">&nbsp;Convert numeric 2D array to string form eg. [[...],...,[...]]&nbsp;&nbsp;</font></li></ul><ul></ul><h3><u>TXGPUCanvas Functions</u></h3><ul><li>function&nbsp; GetGPUParamNumValue(GPUName,pName:String):TNumArray;&nbsp;&nbsp;<font color="#0000ff">For the given TXGPUCanvas component, returns the value of the named numeric parameter as an array&nbsp;</font></li><li>function&nbsp; GetGPUConstIntValue(GPUName,pName:String):integer;&nbsp; <font color="#0000ff">&nbsp;For the given TXGPUCanvas component, returns the value of the named integer parameter&nbsp;</font></li><li>procedure SetGPUParamNumValue(GPUName,pName:String;pValue:TNumArray);&nbsp;&nbsp;<font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named numeric parameter as a 1-D array&nbsp;</font></li><li>procedure SetGPUParam2DNumValue(GPUName,pName:String;pValue:T2DNumArray);&nbsp; &nbsp;<font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named numeric parameter as a 2-D array&nbsp;</font></li><li>procedure SetGPUConstIntValue(GPUName,pName:String;pValue:integer);&nbsp; &nbsp; <font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named integer parameter&nbsp;</font></li><li>function&nbsp; GetGPUPixelArray(GPUName:String):T3DNumArray;&nbsp;&nbsp;<font color="#0000ff">&nbsp;Fetch the current Pixel array for the given TXGPUCanvas component&nbsp;&nbsp;</font></li><li>function&nbsp; GetGPUPixelArrayAsString(GPUName:String):String;&nbsp;&nbsp;<font color="#0000ff">Fetch the current Pixel array in string format for the given TXGPUCanvas component&nbsp;</font>&nbsp;</li><li>function&nbsp; GetGPUStageArray(GPUName:String):T3DNumArray;&nbsp;&nbsp;&nbsp;<font color="#0000ff"> Fetch the stage array (resulting from the non-graphical kernel stack) for the given </font>TXGPUCanvas component&nbsp;&nbsp;</li><li>function&nbsp; GetGPUStageArrayAsString(GPUName:String):String;&nbsp; &nbsp;<font color="#0000ff">Fetch the stage array in string format for the given TXGPUCanvas component&nbsp;&nbsp;</font></li></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><h3>&nbsp;<u>Python Only</u></h3><ul><li>function&nbsp; ShowPythonPlot(ImgName,fig)<font color="#0000ff">&nbsp; In the given TXImage component, displays the contents of fig (a matplotlib figure)&nbsp;</font></li></ul>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br><p><b>App Development and Deployment</b></p><p>During the development phase of a project XIDE&nbsp;will usually be loaded in interactive app design mode where you can edit the user interface design and the code behind it. Here by default, the IDE re-loads the project you were last working on.&nbsp;</p><p>New projects can be started by clearing the current system or loading a previously saved system from the clipboard. This behaves the same in native host environments (Windows or Linux) as it does in Chrome or Android. At the end of this phase, you will sometimes want to deploy the developed app to end users without allowing access to the IDE. In this case, select the "System / Deploy" option from the main menu and this will generate a self contained HTML page implementing your application and the run time environment needed to execute it, but with the interactive IDE features disabled. You can now load this to a server of your choice, or email directly to your end user so they can run it from their file system.&nbsp;</p><p>Alternatively, if you wish to give them access to inspect and perhaps contribute to, or modify, the app, then distribute the blank XIDE app for their preferred platform (Chrome / Linux / Windows / Android) and use the "System / Save" option to generate a app definition file that they can load into it using the "System / Load" option on the main menu.&nbsp;</p><p><b>Debugging</b></p><p>When testing Pascal code you have written using XIDE, the PAS2JS compiler error messages will flag any source code syntax problems. If you click on one of these error messages this will position the cursor at the relevant character position in the line of code in the XIDE&nbsp;code editor. Run time errors will sometimes be trapped by error handlers built in to XIDE&nbsp;and generate a helpful error message. If this is not sufficient to uniquely identify the cause of the problem then "ctrl shift J" in Chrome will bring up the built in developer console which will hopefully provide the additional information you need to track down the problem. Alternatively, a break point can be set in the code by inserting a "DebugStart;" instruction that will start the native browser debug facility at that point.</p><h3>Implementation, Extensibility and Licensing<br></h3><p>XIDE is implemented using the Pas2JS dialect of the Object Pascal programming language. This is because it is efficient, easy to learn, and is available on a wide range of processor architectures.&nbsp;</p><p>Sometimes, as projects go through their life cycle, new more specialist requirements emerge. At this point the XIDE framework can be extended using project or platform specific custom components developed in Lazarus. Alternatively the HTML and JavaScript code generated by XIDE can be imported into a general-purpose web design tool stack to enable full enterprise level development.&nbsp;</p><p>XIDE is an open source project distributed using the same licence as Lazarus (GPL) Source code is avalable from GitHub&nbsp; see <a href="https://github.com/Steve--W/XIDE">here</a> for the IDE and&nbsp;<a href="https://github.com/Steve--W/XComponents">here</a> for the components used to build it. (see <font color="#0000ff">https://github.com/Steve--W/XIDE</font> and<font color="#0000ff"> https://github.com/Steve--W/XComponents</font> respectively)</p><h3>Development Roadmap</h3><p>The initial XIDE project has focused on functionality rather than style, and on the ability to operate as a fully self contained IDE with the minimum of dependencies and a simple learning curve. This was done in order to support experiments in domain specific languages as part of my PhD.<br></p><p>I have made the project open source in case it should prove useful to anyone else. I certainly hope others will take up some of the ideas, because it seems to me that as an open source community, we need to reduce the barriers to entry to cross platform app development. In particular, I am an enthusiast for the use of integrated development environments and drag and drop tree based specification tools to wrap otherwise complex or fragmented APIs.<br></p><p>XIDE is now fulfilling the role that I need it for. Future development will depend on others adopting, adapting and improving it for their own purposes.</p><h3>Compatibility</h3><p>In desktop mode, XIDE is designed to run on platforms supported by&nbsp; Lazarus, and optionally, the&nbsp; Chromium Embedded Framework and&nbsp; Python (i.e. most desktop platforms). If CEF or Python is not available then XIDE can still run but will then not support their specialist features.&nbsp;&nbsp;</p><p>In browser mode XIDE should run on any up to date HTML5 enabled browser. However as it is targeting closed user groups (where the browser can be specified)&nbsp; it is only tested on recent versions of Chrome.&nbsp;</p><p>Alternatively, Electron or Cordova and Crosswalk can be used to provide a hybrid implementation of XIDE. This gives full Web connectivity and CSS on a wide range of platforms but with a trade off in terms of size,speed and security.</p><p>Note that the Style Designer is only available on the Browser versions as it depends on CSS functionality.</p><p><br></p><p><br></p><p></p>';
//'<h1 style="text-align: center;"><u>XIDE Overview</u></h1><h2 style="text-align: center;">&nbsp;(A simple "Browser-First" IDE for Pascal and Python)</h2><h3>Purpose</h3><p>XIDE is a combined Client Side Run Time Library and RAD IDE intended to allow Pascal and/or Python development in the browser with the minimum of installation or learning curve. It is targeted at Prototyping, Small Group Collaboration and Agile Line of Business projects on any platform that is supported by Chrome or Electron, or Lazarus (and the Chrome Embedded Framework).&nbsp; It is not intended for the development of general-purpose public facing web sites.</p><h3>Installation</h3><p>In the browser, XIDE for Chrome is a single page static HTML page with no dependencies. so installation is just a matter of loading that initial web page. All subsequent computation and data storage is done client side. This single page web app&nbsp; combines the currently selected user App, as well as the RTL and IDE Code so any user app can be deployed with the IDE disabled (for end users) or enabled (for collaborators) as required.</p><p>Python in XIDE is based on the Mozilla Pyodide project which brings a full data science stack to the browser, including NumPy, Pandas, and Matplotlib. This can also be used off line if some additional HTML and JS files are installed (alongside&nbsp; XIDE ) to provide the local copy of Pyodide which is otherwise accessed directly from the Pyodide site.&nbsp;</p><p>If using a snapshot of XIDE on the desktop, you need to&nbsp; install local copies of Free Pascal and Python following the relevant instructions on their web sites. Then using the XIDE.exe main menu "Settings" option set the path to the home directories for these applications. Alternatively to rebuild XIDE from source, see ....&nbsp; &nbsp; &nbsp;https://github.com/Steve--W/XIDE.&nbsp;</p><h3>Functionality</h3><p>XIDE is designed to bring the power of Free Pascal (PAS2JS) and the convenience of&nbsp; Rapid Application Development (RAD) to the browser. It&nbsp; is a "Browser First" approach which delivers cross platform capability by replicating browser functionality on the desktop in native code. This allows the user to exploit the greater efficiency of compiled native code compared to interpreted browser environments as required. It also allows a single code base to support multiple different target environments for different user circumstances or different stages in a project.&nbsp;</p><p>The Python options in XIDE adds broader "Data Science" capabilities to the environment and&nbsp; allows the more interactive exploratory approach of Python to be exploited as required. See&nbsp;&nbsp;<a href="https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/">https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/</a></p><h3>Unified User Interface<br></h3><p>The browser supports a number of different standards as part of its user interface. These include HTML, CSS, SVG&nbsp; to cover page layout, style editing, and vector graphics respectively. These all require their own conventions to be used when accessed directly from the browser and/or JavaScript.<br></p><p>XIDE unifies the user''s access to these different browser capabilities using a standardised Object Inspector / Drag and Drop approach for them all. For HTML and SVG this should appear seamless to the user with all the SVG containers and components accessed in an identical manner to HTML so requiring no further explanation than provided below for basic screen layout and editing.&nbsp;</p><h3>CSS Functionality</h3><p>CSS functionality is provided by supporting a style design tree in addition to the Code and UI design trees described below. As with the UI design tree, Style resources (new design rules, targets, properties and rule types ) are dragged from a resources tree and dropped on the relevant node of the style tree. The style tree also supports logical grouping of targets using "AND" and "OR" nodes.&nbsp; This speeds up and simplifies the CSS syntax generation considerably compared to direct text entry.</p><p></p><h3>Designing a User Interface<br></h3><p><b>Resource and Instance trees</b></p><p>XIDE uses a very simple paradigm. Essentially, it consists of three elements.</p><p></p><ol><li>&nbsp;A resources tree, showing the available widgets (visual and non visual)</li><li>&nbsp;A system design tree and object property inspector/editor</li><li>&nbsp;A layout panel showing a WYSIWYG version of the current page design.</li></ol><p></p> <p>The UI is built by pasting nodes from the resource tree to the system design tree. Each node has object properties defined by a name/value pairs that can be edited using the object inspector or referenced and or updated by run time code. Events are also available on each widget so that code can be attached to them using the built in code editor and compiler.&nbsp;</p><p><b>Available widgets</b></p><p>The widgets listed in the resource tree include both UI and non visual components (the latter can be added to the root node of the UI design tree).&nbsp;</p><p><b>Responsive Design</b></p><p>XIDE supports a simple Responsive Design layout paradigm which consists of a Main page, Tab controls and Popups to define the constituent pages in a UI design. Horizontal and Vertical layout boxes (together with associated alignment properties) are then nested within these pages to control the final layout of components on the page.</p><p><b>Writing application code</b></p><p>XIDE uses an event driven model where event handlers written in Pascal and/or Python can be attached to pre defined events triggered by objects in the user interface. These procedures can be inspected and/or edited by using the object inspector to navigate to the required UI object then pressing the ellipsis button to the right of the required event in its events tab. This creates an entry for that event handler under the "Event Handlers" node in the code design tree. So once a handler has been added it can then also be navigated to by selecting it in the code designer and pressing the edit button.&nbsp;</p><p><b>Pascal Syntax</b></p><p>The Pascal syntax recognised by XIDE&nbsp;is that used by the Pas2JS variant of Free Pascal. (http://wiki.freepascal.org/pas2js). A detailed description of the supported syntax can be found here. (http://wiki.freepascal.org/pas2js#RTL)</p><p><b>Unit Structure</b></p><p>In addition to the event handler nodes, shared code can be written by adding units directly to the code design tree as "Pascal Units" These must have the "Interface" unit added to their uses clause in order to be able to access the XIDE API. In addition, they can access any of the standard set of PAS2JS run time library units. (http://wiki.freepascal.org/pas2js#RTL)&nbsp;</p><p>Functions and procedures&nbsp; in these "Pascal Unit" notes can be amended, added to or deleted by selecting the node on the code design tree and pressing the "Edit" button which will bring up the code editor screen as previously described for&nbsp; the event handler code. After a Pascal unit has been compiled for the first time in a session, all the procedures and functions declared in it are displayed as its child nodes in the code design tree. Selecting one of these nodes and pressing the edit button below will navigate directly to that code. Alternatively, selecting a node and pressing "Code Search" will list all references to that function or procedure allowing you to navigate directly to the most relevant reference.</p><h3><b>Python&nbsp;</b></h3><p>The Python syntax used is version 3.8.&nbsp;</p><p>Python does not have a unit structure like Pascal, however blocks of Python code can be added to the Code Designer tree in the same way as Pascal units. The difference is that these will be run&nbsp; when entering run mode. They are executed in the order they occur on the Code Designer tree and can contain initialisation, declarations and / or&nbsp; any other valid executable Python Code.&nbsp;</p><p>To execute Python code elsewhere, such as in an event handler, then simply invoke the "RunPython(<i>......</i>)" procedure with the relevant python procedure call (or code) as a string parameter,</p><h3>Using Python Interactively</h3><p>Console input and output boxes are supplied so that Python can be used interactively. On the desktop, the copy of Python being used is the version installed on the host machine, see the documentation for that system to review valid syntax, permissions etc. In the browser, the version of Python used is that supported by mozilla (see&nbsp;<a href="https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/">https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/</a>)</p><p><b>Accessing user interface objects at run time</b></p><p>XIDE is designed to be a cross platform rapid application development system. In order to do this it uses a text based system description tree (The System Design or Instance Tree) to reflect the state of a users program at all time. This is similar to the function of the Document Object Model (DOM) in standard web applications.</p> <p><b>Types of API Calls</b></p><p>In XIDE&nbsp;the instance tree describing a users project can be inspected manually using the Object Inspector. This allows the user to select any node on the tree and inspect and/or modify its properties or event handlers as required. The XIDE&nbsp;API allows the same actions to be available programmatically. This ability to generate events using code is particularly useful in automated testing, asynchronous call back functions, or multi threading applications. The functions available fall into eight types (and work in an identical manner in both Pascal and Python) viz:-</p><p></p><ul><li>&nbsp;Dialog boxes</li><li>&nbsp;Get and/or set a property value of a UI object</li><li>&nbsp;Save and load user selected data to the clipboard</li><li>&nbsp;copy or delete a UI component or move it to a new parent.</li><li>&nbsp;Add to, or replace, the event response for a UI object and/or trigger such an event artificially</li><li>&nbsp;Show or hide a popup form.</li><li>&nbsp;Show or hide a busy indicator.</li><li>&nbsp;get and set GPU parameters (integer,number and image)</li></ul><p></p><p>The detail syntax for these function calls is appended below. Note that unless explicitly stated, all values are either strings or string arrays.</p><p><b>Asynchronous Calls, Multi Threading and Initialization functions</b></p><p>Many web calls issue requests that need to wait for a response from a web service, database or other remote service provider. Similarly, when starting another thread in parallel, the main thread will often need to wait for such child threads to return the results of their work before it can proceed. XIDE&nbsp;allows main event handlers to specify a "initalisation"function. This is a block of code which issues all such requests prior to running the main event code when they have all finished executing. See below for the detail syntax of the available calls.</p><p>Note however that all such asynchronous calls first parameter is "e" the event context (automatically declared and populated by XIDE, behind the scenes, for every XIDE&nbsp;event) from which they have been issued so they know where to return without requiring the user to enter complex boilerplate code.</p><h3><b><u>List of&nbsp;XIDE&nbsp;specific API procedure and function calls</u></b></h3> <p></p><h3><u>General Functions</u></h3><ul><li>procedure SetPropertyValue(nodeName,propName,newValue:String);&nbsp;&nbsp;&nbsp; &nbsp;<font color="#0000ff">set a component property (string value)&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;GetPropertyValue(nodeName,propName:String);&nbsp;<font color="#0000ff">&nbsp; &nbsp;returns a component property value (as string)&nbsp;</font></li><li>procedure SetPropertyValueIndexed(nodeName,propName:String;newValue:TStringArray; x,y:integer);&nbsp;&nbsp; &nbsp;<font color="#0000ff">set a portion of a component array property</font>&nbsp;&nbsp;</li><li>procedure CopyToClip(str:String);&nbsp;&nbsp;<font color="#0000ff">&nbsp;copies the given string to the clipboard&nbsp;</font></li><li>function&nbsp; &nbsp;CopyFromClip(e:TEventStatus):String;&nbsp;&nbsp;&nbsp;<font color="#0000ff">CopyFromClip is an async function (required for browser use), so it must be coded in the&nbsp;&nbsp;''Init'' section of an event handler. The result here is a blank string.&nbsp;&nbsp;&nbsp;The clipboard string is held in e.ReturnString, which cn be picked up in the&nbsp;&nbsp;&nbsp; &nbsp;''Main'' section of the event handler.</font></li><li>procedure ShowXForm(XFormID:String; modal:Boolean);&nbsp;&nbsp;<font color="#0000ff">&nbsp;opens a TXForm. [note:''modal=false'' currently only effective on desktop]&nbsp;</font></li><li>procedure CloseXForm(XFormID:String);&nbsp;&nbsp;<font color="#0000ff">&nbsp;closes a TXForm.&nbsp;&nbsp;</font></li><li>procedure DoEvent(EventType,NodeId,myValue:String);&nbsp;<font color="#0000ff"> executes the event handler defined for the given event type and component.&nbsp;</font></li><li>procedure MoveComponent(nodeId:string;NewParentId:string);&nbsp;&nbsp;<font color="#0000ff">re-parents the given UI component&nbsp;</font></li><li>procedure CopyComponent(nodeId,NewParentId,NewName:string);&nbsp;<font color="#0000ff">copies the given UI component and places the clone under the given parent&nbsp;</font></li><li>function&nbsp; &nbsp;DeleteComponent(nodeId:string;ShowNotFoundMsg:Boolean=true):Boolean;&nbsp;&nbsp; <font color="#0000ff">&nbsp;deletes the given UI component. Returns false if not done.&nbsp;</font></li><li>function&nbsp; &nbsp;UserSystemAsString():String;&nbsp; <font color="#0000ff">Returns the string representation of the current user system (can be imported to XIDE via System&gt;Load)&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;LoadUserSystemString(SystemString:String);&nbsp;&nbsp;<font color="#0000ff">Imports a new user system to the XIDE framework (can only be done in ''Design'' mode)&nbsp;</font></li><li>procedure ShowBusy(e:TEventStatus);&nbsp;&nbsp;<font color="#0000ff">Shows the busy cursor&nbsp;ShowBusy is an async function (required for browser use), so it must be coded in the&nbsp; ''Init'' section of an event handler.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></li><li>procedure HideBusy;&nbsp; &nbsp;<font color="#0000ff">Hides the busy cursor&nbsp;</font>&nbsp;</li><li>procedure ProcessMessages;&nbsp; <font color="#0000ff">&nbsp;Functional in Desktop execution only.&nbsp; Executes a pascal Application.ProcessMessages statement.&nbsp;&nbsp;</font></li><li>procedure DebugStart;&nbsp; &nbsp;<font color="#0000ff">Functional in Browser execution only.&nbsp; Executes a Javascript ''debugger;'' statement - starts the native browser debug facility.&nbsp;&nbsp;</font></li><li>procedure RunPython(str:String);&nbsp;<font color="#0000ff">&nbsp;Executes the given Python script&nbsp;</font></li></ul></div><div contenteditable="true"><ul></ul><h3><u>Messages and Dialogs</u></h3><ul><li>procedure ShowMessage(msg:String);&nbsp; <font color="#0000ff">&nbsp;displays a popup alert&nbsp;</font></li><li>function&nbsp; &nbsp;Confirm(TextMessage:string):boolean;&nbsp;&nbsp;<font color="#0000ff">displays a confirmation alert; returns true/false&nbsp;</font></li><li>function&nbsp; &nbsp;Prompt(TextMessage,promptString:string):string;&nbsp;&nbsp;&nbsp;<font color="#0000ff">displays an input box; returns user-entered string&nbsp;</font></li><li>procedure ConsoleLog(txt:String);&nbsp; <font color="#0000ff">Writes a debug message to the console log&nbsp;&nbsp;</font></li></ul><ul></ul><h3><u>TXTable Functions</u></h3><ul><li>procedure&nbsp; LoadTableFromExcelCopy(TableName,CopiedString:String);&nbsp;&nbsp;<font color="#0000ff">Populate the given TXTable component with a string in Excel format (eg. as copied from a spreadsheet)&nbsp;&nbsp;</font></li><li>procedure&nbsp; LoadTableFromNumArray(TableName,NumArray:T2DNumArray);&nbsp;&nbsp;<font color="#0000ff">Populate the given TXTable component from a 2D numeric array&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;GetTableDataArray(TableName:String;SkipHeader:Boolean):T2DStringArray;&nbsp;&nbsp;<font color="#0000ff">&nbsp;Fetch the cells from the given TXTable component as a 2D string array&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;Array2DToString(arr:T2DNumArray):String;&nbsp; <font color="#0000ff">&nbsp;Convert numeric 2D array to string form eg. [[...],...,[...]]&nbsp;&nbsp;</font></li></ul><ul></ul><h3><u>TXGPUCanvas Functions</u></h3><ul><li>function&nbsp; &nbsp;GetGPUParamNumValue(GPUName,pName:String):TNumArray;&nbsp;&nbsp;<font color="#0000ff">For the given TXGPUCanvas component, returns the value of the named numeric parameter as an array&nbsp;</font></li><li>function&nbsp; &nbsp;GetGPUConstIntValue(GPUName,pName:String):integer;&nbsp; <font color="#0000ff">&nbsp;For the given TXGPUCanvas component, returns the value of the named integer parameter&nbsp;</font></li><li>procedure SetGPUParamNumValue(GPUName,pName:String;pValue:TNumArray);&nbsp;&nbsp;<font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named numeric parameter as a 1-D array&nbsp;</font></li><li>procedure SetGPUParam2DNumValue(GPUName,pName:String;pValue:T2DNumArray);&nbsp; &nbsp;<font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named numeric parameter as a 2-D array&nbsp;</font></li><li>procedure SetGPUConstIntValue(GPUName,pName:String;pValue:integer);&nbsp; &nbsp; <font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named integer parameter&nbsp;</font></li><li>function&nbsp; &nbsp;GetGPUPixelArray(GPUName:String):T3DNumArray;&nbsp;&nbsp;<font color="#0000ff">&nbsp;Fetch the current Pixel array for the given TXGPUCanvas component&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;GetGPUPixelArrayAsString(GPUName:String):String;&nbsp;&nbsp;<font color="#0000ff">Fetch the current Pixel array in string format for the given TXGPUCanvas component&nbsp;</font>&nbsp;</li><li>function&nbsp; &nbsp;GetGPUStageArray(GPUName:String):T3DNumArray;&nbsp;&nbsp;&nbsp;<font color="#0000ff"> Fetch the stage array (resulting from the non-graphical kernel stack) for the given </font>TXGPUCanvas component&nbsp;&nbsp;</li><li>function&nbsp; &nbsp;GetGPUStageArrayAsString(GPUName:String):String;&nbsp; &nbsp;<font color="#0000ff">Fetch the stage array in string format for the given TXGPUCanvas component&nbsp;&nbsp;</font></li></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><h3>&nbsp;<u>Python Only</u></h3><ul><li>function&nbsp; ShowPythonPlot(ImgName,fig)<font color="#0000ff">&nbsp; In the given TXImage component, displays the contents of fig (a matplotlib figure)&nbsp;</font></li></ul>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br><p><b>App Development and Deployment</b></p><p>During the development phase of a project XIDE&nbsp;will usually be loaded in interactive app design mode where you can edit the user interface design and the code behind it. Here by default, the IDE re-loads the project you were last working on. Alternatively, they can be set to revert to the original state every time the app is started.</p><p>New projects can be started by clearing the current system or loading a previously saved system from the clipboard. This behaves the same in native host environments (Windows or Linux) as it does in Chrome or Android. At the end of this phase, you will sometimes want to deploy the developed app to end users without allowing access to the IDE. In this case, select the "System / Deploy" option from the main menu and this will generate a self contained HTML page implementing your application and the run time environment needed to execute it, but with the interactive IDE features disabled. You can now load this to a server of your choice, or email directly to your end user so they can run it from their file system.&nbsp;</p><p>Alternatively, if you wish to give them access to inspect and perhaps contribute to, or modify, the app, then distribute the blank XIDE app for their preferred platform (Chrome / Linux / Windows / Android) and use the "System / Save" option to generate a app definition file that they can load into it using the "System / Load" option on the main menu.&nbsp;</p><p><b>Debugging</b></p><p>When testing Pascal code you have written using XIDE, the PAS2JS compiler error messages will flag any source code syntax problems. If you click on one of these error messages this will position the cursor at the relevant character position in the line of code in the XIDE&nbsp;code editor. Run time errors will sometimes be trapped by error handlers built in to XIDE&nbsp;and generate a helpful error message. If this is not sufficient to uniquely identify the cause of the problem then "ctrl shift J" in Chrome will bring up the built in developer console which will hopefully provide the additional information you need to track down the problem. Alternatively, a break point can be set in the code by inserting a "DebugStart;" instruction that will start the native browser debug facility at that point.</p><h3>Implementation, Extensibility and Licensing<br></h3><p>XIDE is implemented using the Pas2JS dialect of the Object Pascal programming language. This is because it is efficient, easy to learn, and is available on a wide range of processor architectures.&nbsp;</p><p>Sometimes, as projects go through their life cycle, new more specialist requirements emerge. At this point the XIDE framework can be extended using project or platform specific custom components developed in Lazarus.&nbsp;</p><p>XIDE is an open source project distributed using the same licence as Lazarus (GPL) Source code is available from GitHub&nbsp; see <a href="https://github.com/Steve--W/XIDE">here</a> for the IDE and&nbsp;<a href="https://github.com/Steve--W/XComponents">here</a> for the components used to build it. (see <font color="#0000ff">https://github.com/Steve--W/XIDE</font> and<font color="#0000ff"> https://github.com/Steve--W/XComponents</font> respectively)</p><h3>Development Roadmap</h3><p>I am currently (Sept 2020) using XIDE on a daily basis to support my academic research projects. I have made the project open source in case it should prove useful to anyone else. In particular, I hope its browser first approach, low installation overhead and easy learning curve will help to introduce the&nbsp; joys of Free Pascal and Lazarus to a wider audience.<br></p><p>Those aspects of XIDE and XComponents that I use regularly are "tried and tested". Some aspects that are used less often may have more bugs, and there are many aspects where it would be great to add new or improved features but where I do not have the bandwidth or skill to address at the moment. If&nbsp; anyone wants to help out with any improvement to XIDE then their contribution will be most welcome.</p><p>(Some topics that spring to mind, from a long list of potential improvements, are:-&nbsp; XIDE integration with Lazarus, improving the wrapper for GPUJS or adding a drag and drop utility for constructing MatPlotLib data visualisations to make these Python libraries easily accessible to the Pascal community. )</p><h3>Compatibility</h3><p>In desktop mode, XIDE is designed to run on platforms supported by&nbsp; Lazarus, and optionally, the&nbsp; Chromium Embedded Framework and&nbsp; Python (i.e. most desktop platforms). If CEF or Python is not available then XIDE can still run but will then not support their specialist features.&nbsp; Alternatively, Electron or Cordova and Crosswalk can be used to provide a hybrid implementation of XIDE. This gives full Web connectivity and CSS on a wide range of platforms but with a trade off in terms of size, speed and security.</p><p>In browser mode XIDE is targeting closed user groups (where the browser can be specified) so it is only tested on recent versions of Chrome but it may also work on other browsers which use a Chrome engine. (e.g. the latest version of Microsoft Edge)&nbsp;</p><p>Note that the Style Designer is only available on the Browser versions as it depends on CSS functionality.</p><h3>Motivation for including a GPU capability in XIDE</h3><p>XIDE provides a thin wrapper for GPUJS (See https://gpu.rocks/) which generates GPU code from JavaScript. This produces WebGL code as it is widely supported "out of the box"&nbsp; in most browsers and on most processor/GPU combinations. This minimises the&nbsp; installation and configuration needed in order to get GPU code running on a new system. As such it is a good way to start learning about the possibilities (and perhaps more importantly the limitations) of programming for a massively parallel platform.&nbsp;</p><p>One of the weaknesses of this approach is the frustrating inability to optimise code or diagnose bugs in the GPU kernels except by exhaustive trial and error.&nbsp; So for any serious GPU programming it is well worth investing the time in getting to grips with the (admittedly intimidating) learning curve needed to master tools like OpenCL or Cuda and the associated tool stacks. Having said that, for simple "embarrassingly parallel" examples, or where there is a need to build simple GPU code into more general purpose or widely shared apps, the GPUJS approach can be very helpful.</p><h3>The XIDE GPUJS Wrapper</h3><p>The Pascal code for the GPU is accessed as a property of a GPU Canvas component which has been dropped onto the User Interface layout screen and/or as a node on the Code designer tree.&nbsp; The Pascal GPU code editor follows the same edit/compile cycle as for user code in the rest of the system. The differences are that this is code for blocks of threads in parallel. The code describes a single instruction multiple data (SIMD) approach where all the threads run the same code with thread specific code referencing "this.thread.x" , "this.thread.y" and "this.thread.z"to reflect their position in the block of threads. Parameter names are declared using a Paramlist property of the GPU canvas component and their transfer and run time execution is controlled by system calls described below. (N.B. parameters need to be passed as arrays so even scalar parameters passed into the code need to be referenced as follows "myParam[0]" )<br></p><p>The Pascal GPU code can daisy chain kernels. (Set the TXGPUCanvas property NumKernels&gt;1) For each kernel in the chain its return value must be set to "MyValue". The next kernel in the chain can then read all the thread return values from the previous kernel by reading from "MyArray".The initial "MyArray" passed to the first kernel in the chain is set as a property ("InitStageData") of the GPU canvas and can have any x,y,z sizes as chosen by the user. The final&nbsp; &nbsp;kernel is the graphics display kernel where you set the r,g,b values as usual. The calculated data input to the graphics display kernel can also be accessed using either the "GetGPUStageArray" or "GetGPUStageArrayAsString" instructions;</p><p>Maths functions available in the GPU code are as follows:-</p><p></p><ul><li>abs(a) sign(a) trunc(a) ceil(a) max(a,b) min(a,b)</li><li>sin(a) cos(a) arcsin(a) arccos(a) arctan(a,b)</li><li>sqrt(a) power(a,b) ln(a) log10(a) log2(a)&nbsp;</li></ul><h3>Limitations of coding for the GPU&nbsp;</h3><p>When coding in Pascal for the GPU, you should be aware that there are fundamental limitations on the constructs available. In particular:-</p><p></p><ul><li>All parameters passed into the GPU&nbsp; are real arrays (scalar parameters are real arrays of length one)<br></li><li>You can read from but not write to any of these array parameters</li><li>You cannot declare a local array</li><li>Each thread returns a single real value</li><li>You cannot communicate with any other thread (except by synchronising the results in a new kernel)</li><li>You cannot use a Boolean type (use 0 or 1 instead)</li><li>You cannot use "Var" parameters in a function call</li><li>All function parameters must be a simple type</li><li>Nested function declarations do not follow normal (Pascal) scope rules</li><li>Loops are unrolled so you MUST SET the "<span style="font-family: Verdana, Arial, sans-serif; font-size: 12px; white-space: nowrap;">MaxIterations"</span>&nbsp;parameter at a high enough value to reflect your algorithm''s requirements</li><li>The number of threads in each kernel are given by the KernelXDims, KernelYDims and Kernel ZDims properties of the GPU Canvas and these MUST BE SET either manually or programatically before activating the GPU.</li><li>The GPU is a Single Instruction Multiple Data machine so branching in a thread does not jump over the code in the path not taken,&nbsp; it idles in order to allow other threads to execute the code in that path if need be.&nbsp;</li><li>Debugging on the GPU is "primitive" the only way to do it when running on the hardware is to write out intermediate results&nbsp; to the thread output value for selected threads which you dedicate to providing diagnostic output.&nbsp;</li></ul><p><br></p><p><br></p><p></p>';
'<h1 style="text-align: center;"><u>XIDE Overview</u></h1><h2 style="text-align: center;">&nbsp;(A simple "Browser-First" IDE for Pascal and Python)</h2><h3>Purpose</h3><p>XIDE is a combined Client Side Run Time Library and RAD IDE intended to allow Pascal and/or Python development in the browser with the minimum of installation or learning curve. It is targeted at Prototyping, Small Group Collaboration and Agile Line of Business projects on any platform that is supported by Chrome or Electron, or Lazarus (and the Chrome Embedded Framework).&nbsp; It is not intended for the development of general-purpose public facing web sites.</p><h3>Installation</h3><p>In the browser, XIDE for Chrome is a single page static HTML page with no dependencies. so installation is just a matter of loading that initial web page. All subsequent computation and data storage is done client side. This single page web app&nbsp; combines the currently selected user project, as well as the RTL and IDE Code so any user project can be deployed with the IDE disabled (for end users) or enabled (for collaborators) as required.</p><p>Python in XIDE is based on the Mozilla Pyodide project which brings a full data science stack to the browser, such as NumPy, Pandas and Matplotlib.&nbsp;</p><p>If using a snapshot of XIDE on the desktop (i.e. XIDE.exe), you need to&nbsp; install local copies of Free Pascal and Python following the relevant instructions on their websites. Then using the XIDE.exe main menu "Settings" option set the path to the home directories for the fpc compiler. Alternatively to rebuild XIDE from source, see&nbsp;&nbsp;<a href="https://github.com/Steve--W/XIDE">https://github.com/Steve--W/XIDE.</a>&nbsp;</p><h3>Functionality</h3><p>XIDE is designed to bring the power of Free Pascal (Pas2JS) and the convenience of&nbsp; Rapid Application Development (RAD) to the browser. It&nbsp; is a "Browser First" approach which also delivers cross platform capability by replicating browser functionality on the desktop in native code. This allows the user to exploit the greater efficiency of compiled native code compared to interpreted browser environments as required. It also allows a single code base to support multiple different target environments for different user circumstances or different stages in a project.&nbsp;</p><p>The Python option in XIDE adds broader "Data Science" capabilities to the environment and&nbsp; allows the more interactive exploratory approach of Python to be exploited as required. See&nbsp;&nbsp;<a href="https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/">https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/</a></p><h3>Unified User Interface<br></h3><p>The browser supports a number of different standards as part of its user interface. These include HTML, CSS, SVG&nbsp; to cover page layout, style editing, and vector graphics respectively. Normally these all require their own conventions to be used when accessed directly from the browser and/or JavaScript. XIDE unifies the user''s access to these different browser capabilities using a standardised Object Inspector / Drag and Drop approach for them all. For HTML and SVG this should appear seamless to the user with all the SVG containers and components accessed in an identical manner to HTML so requiring no further explanation than provided below for basic screen layout and editing.&nbsp;</p><h3>CSS Functionality</h3><p>CSS functionality is provided by supporting a style design tree in addition to the Code and UI design trees described below. As with the UI design tree, Style resources (new design rules, targets, properties and rule types ) are dragged from a resources tree and dropped on the relevant node of the style tree. The style tree also supports logical grouping of targets using "AND" and "OR" nodes.&nbsp; This speeds up and simplifies the CSS syntax generation considerably compared to direct text entry.</p><p></p><h3>Designing a User Interface<br></h3><p><b>Resource and Instance trees</b></p><p>XIDE uses a very simple paradigm. Essentially, it consists of three elements.</p><p></p><ol><li>&nbsp;A resources tree, showing the available widgets (visual and non visual)</li><li>&nbsp;A system design tree and object property inspector/editor</li><li>&nbsp;A layout panel showing a WYSIWYG version of the current page design.</li></ol><p></p> <p>The UI is built by pasting nodes from the resource tree to the system design tree. Each node has object properties defined by a name/value pairs that can be edited using the object inspector or referenced and or updated by run time code. Events are also available on each widget so that Pascal code can be attached to them using the built in code editor and compiler. Python scripts can also be called from these event handlers.</p><p><b>Available Widgets</b></p><p>The widgets listed in the resource tree include both UI and non visual components (the latter can be added to the root node of the UI design tree).&nbsp;</p><p><b>Responsive Design</b></p><p>XIDE supports a simple Responsive Design layout paradigm which consists of a Main page, Tab controls and Popups to define the constituent pages in a UI design. Horizontal and Vertical layout boxes (together with associated alignment properties) are then nested within these pages to control the final layout of components on the page.</p><p><b>Writing Application Code</b></p><p>XIDE uses an event driven model where event handlers can be attached to pre-defined events triggered by objects in the user interface. These procedures can be inspected and/or edited by using the object inspector to navigate to the required UI object then pressing the ellipsis button to the right of the required event in its events tab. This creates an entry for that event handler under the "Event Handlers" node in the code design tree. So once a handler has been added it can then also be navigated to by selecting it in the code designer and pressing the edit button.&nbsp;</p><p><b>Pascal Syntax</b></p><p>The Pascal syntax recognised by XIDE&nbsp;is that used by the Pas2JS variant of Free Pascal. (<a href="http://wiki.freepascal.org/pas2js">http://wiki.freepascal.org/pas2js</a>). A detailed description of the supported syntax can be found here. (<a href="http://wiki.freepascal.org/pas2js#RTL">http://wiki.freepascal.org/pas2js#RTL</a>)</p><p><b>Unit Structure</b></p><p>In addition to the event handler nodes, shared code can be written by adding units directly to the code design tree as "Pascal Units" or "Python Scripts".&nbsp;&nbsp;</p><p>Functions and procedures&nbsp; in the code nodes can be amended or deleted by selecting the node on the code design tree and pressing the "Edit" button which will bring up the code editor screen as previously described for&nbsp; the event handler code. After a Pascal unit has been compiled for the first time in a session, all the procedures and functions declared in it are displayed as its child nodes in the code design tree. Selecting one of these nodes and pressing the edit button below will navigate directly to that function. Alternatively, selecting a node and pressing "Code Search" will list all references to that function or procedure allowing you to navigate directly to the most relevant reference.</p><h3><b>Python&nbsp;</b></h3><p>The Python syntax used is version 3.8.&nbsp;</p><p>Python does not have a unit structure like Pascal, however blocks of Python code can be added to the Code Designer tree in the same way as Pascal units. The difference is that these will be run&nbsp; when entering run mode. They are executed in the order they occur on the Code Designer tree and can contain initialisation, declarations and / or&nbsp; any other valid executable Python Code.&nbsp;</p><p>To execute Python code elsewhere, such as in an event handler, then simply invoke the "RunPython(<i>......</i>)" procedure with the relevant python function call (or code) as a string parameter,</p><p>A console output box is supplied so that Python errors and print statements can be viewed. On the desktop, the copy of Python being used is the version installed on the host machine, see the documentation for that system to review valid syntax, permissions etc. In the browser, the version of Python used is that supported by mozilla (see&nbsp;<a href="https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/">https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/</a>)</p><p><b>Accessing user interface objects at run time</b></p><p>XIDE is designed to be a cross platform rapid application development system. In order to do this it uses a text based system description tree (The System Design or Instance Tree) to reflect the state of a users program at all times. This is similar to the function of the Document Object Model (DOM) in standard web applications. All object properties for nodes on this tree can be accessed and updated using the supplied get and set calls (see below).</p> <p><b>Types of API Calls</b></p><p>In XIDE design mode the instance tree describing a users project can be inspected manually using the Object Inspector. This allows the user to select any node on the tree and inspect and/or modify its properties or event handlers as required. The XIDE&nbsp;API allows the same actions to be available programmatically. The functions available fall into the following types (and work in an identical manner in both Pascal and Python) viz:-</p><p></p><ul><li>&nbsp;Dialog boxes</li><li>&nbsp;Get and/or set a property value of a UI object</li><li>&nbsp;Save and load user selected data to the clipboard or local storage</li><li>&nbsp;Copy or delete a UI component or move it to a new parent.</li><li>&nbsp;Show or hide a popup form.</li><li>&nbsp;Show or hide a busy indicator.</li><li>&nbsp;get and set GPU parameters&nbsp;</li></ul><p></p><p>The detailed syntax for these function calls is appended below. Note that unless explicitly stated, all values are strings.</p><p><b>Asynchronous Calls, Multi Threading and Initialization functions</b></p><p>Many web calls issue requests that need to wait for a response from a web service, database or other remote service provider. Similarly, when starting another thread in parallel, the main thread will often need to wait for such child threads to return the results of their work before it can proceed. XIDE&nbsp;allows main event handlers to specify a "initalisation"function. This is a block of code which issues all such requests prior to running the main event code when they have all finished executing. See below for the detail syntax of the available calls.</p><p>Note however that all such asynchronous calls first parameter is "e" the event context (automatically declared and populated by XIDE, behind the scenes, for every XIDE&nbsp;event) from which they have been issued so they know where to return without requiring the user to enter complex boilerplate code.</p><h3><b><u>List of&nbsp;XIDE&nbsp;specific API procedure and function calls</u></b></h3> <p></p><h3><u>General Functions</u></h3><ul><li>procedure SetPropertyValue(nodeName,propName,newValue:String);&nbsp;&nbsp;&nbsp; &nbsp;<font color="#0000ff">set a component property (string value)&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;GetPropertyValue(nodeName,propName:String);&nbsp;<font color="#0000ff">&nbsp; &nbsp;returns a component property value (as string)&nbsp;</font></li><li>procedure SetPropertyValueIndexed(nodeName,propName:String;newValue:TStringArray; x,y:integer);&nbsp;&nbsp; &nbsp;<font color="#0000ff">set a portion of a component array property</font>&nbsp;&nbsp;</li><li>procedure CopyToClip(str:String);&nbsp;&nbsp;<font color="#0000ff">&nbsp;copies the given string to the clipboard&nbsp;</font></li><li>function&nbsp; &nbsp;CopyFromClip(e:TEventStatus):String;&nbsp;&nbsp;&nbsp;<font color="#0000ff">CopyFromClip is an async function (required for browser use), so it must be coded in the&nbsp;&nbsp;''Init'' section of an event handler. The result here is a blank string.&nbsp;&nbsp;&nbsp;The clipboard string is held in e.ReturnString, which cn be picked up in the&nbsp;&nbsp;&nbsp; &nbsp;''Main'' section of the event handler.</font></li><li>procedure ShowXForm(XFormID:String; modal:Boolean);&nbsp;&nbsp;<font color="#0000ff">&nbsp;opens a TXForm. [note:''modal=false'' currently only effective on desktop]&nbsp;</font></li><li>procedure CloseXForm(XFormID:String);&nbsp;&nbsp;<font color="#0000ff">&nbsp;closes a TXForm.&nbsp;&nbsp;</font></li><li>procedure DoEvent(EventType,NodeId,myValue:String);&nbsp;<font color="#0000ff"> executes the event handler defined for the given event type and component.&nbsp;</font></li><li>procedure MoveComponent(nodeId:string;NewParentId:string);&nbsp;&nbsp;<font color="#0000ff">re-parents the given UI component&nbsp;</font></li><li>procedure CopyComponent(nodeId,NewParentId,NewName:string);&nbsp;<font color="#0000ff">copies the given UI component and places the clone under the given parent&nbsp;</font></li><li>function&nbsp; &nbsp;DeleteComponent(nodeId:string;ShowNotFoundMsg:Boolean=true):Boolean;&nbsp;&nbsp; <font color="#0000ff">&nbsp;deletes the given UI component. Returns false if not done.&nbsp;</font></li><li>function&nbsp; &nbsp;UserSystemAsString():String;&nbsp; <font color="#0000ff">Returns the string representation of the current user system (can be imported to XIDE via System&gt;Load)&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;LoadUserSystemString(SystemString:String);&nbsp;&nbsp;<font color="#0000ff">Imports a new user system to the XIDE framework (can only be done in ''Design'' mode)&nbsp;</font></li><li>procedure ShowBusy(e:TEventStatus);&nbsp;&nbsp;<font color="#0000ff">Shows the busy cursor&nbsp;ShowBusy is an async function (required for browser use), so it must be coded in the&nbsp; ''Init'' section of an event handler.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></li><li>procedure HideBusy;&nbsp; &nbsp;<font color="#0000ff">Hides the busy cursor&nbsp;</font>&nbsp;</li><li>procedure ProcessMessages;&nbsp; <font color="#0000ff">&nbsp;Functional in Desktop execution only.&nbsp; Executes a pascal Application.ProcessMessages statement.&nbsp;&nbsp;</font></li><li>procedure DebugStart;&nbsp; &nbsp;<font color="#0000ff">Functional in Browser execution only.&nbsp; Executes a Javascript ''debugger;'' statement - starts the native browser debug facility.&nbsp;&nbsp;</font></li><li>procedure RunPython(str:String);&nbsp;<font color="#0000ff">&nbsp;Executes the given Python script&nbsp;</font></li><li>procedure PyodideLoadPackage(nm:String);&nbsp;<font color="#0000ff">&nbsp;Functional in Browser execution only.&nbsp; Loads the requested Pyodide/python package, so that it will be available for import.&nbsp;</font></li><li>function PyodidePackageLoaded(nm:String):Boolean;&nbsp;<font color="#0000ff">&nbsp;Functional in Browser execution only.&nbsp; Returns true if the named package has been loaded into the Pyodide environment.&nbsp;&nbsp;</font>&nbsp; &nbsp;</li></ul></div><div contenteditable="true"><ul></ul><h3><u>Messages and Dialogs</u></h3><ul><li>procedure ShowMessage(msg:String);&nbsp; <font color="#0000ff">&nbsp;displays a popup alert&nbsp;</font></li><li>function&nbsp; &nbsp;Confirm(TextMessage:string):boolean;&nbsp;&nbsp;<font color="#0000ff">displays a confirmation alert; returns true/false&nbsp;</font></li><li>function&nbsp; &nbsp;Prompt(TextMessage,promptString:string):string;&nbsp;&nbsp;&nbsp;<font color="#0000ff">displays an input box; returns user-entered string&nbsp;</font></li><li>procedure ConsoleLog(txt:String);&nbsp; <font color="#0000ff">Writes a debug message to the console log&nbsp;&nbsp;</font></li></ul><ul></ul><h3><u>TXTable Functions</u></h3><ul><li>procedure&nbsp; LoadTableFromExcelCopy(TableName,CopiedString:String);&nbsp;&nbsp;<font color="#0000ff">Populate the given TXTable component with a string in Excel format (eg. as copied from a spreadsheet)&nbsp;&nbsp;</font></li><li>procedure&nbsp; LoadTableFromNumArray(TableName,NumArray:T2DNumArray);&nbsp;&nbsp;<font color="#0000ff">Populate the given TXTable component from a 2D numeric array&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;GetTableDataArray(TableName:String;SkipHeader:Boolean):T2DStringArray;&nbsp;&nbsp;<font color="#0000ff">&nbsp;Fetch the cells from the given TXTable component as a 2D string array&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;Array2DToString(arr:T2DNumArray):String;&nbsp; <font color="#0000ff">&nbsp;Convert numeric 2D array to string form eg. [[...],...,[...]]&nbsp;&nbsp;</font></li></ul><ul></ul><h3><u>TXGPUCanvas Functions</u></h3><ul><li>function&nbsp; &nbsp;GetGPUParamNumValue(GPUName,pName:String):TNumArray;&nbsp;&nbsp;<font color="#0000ff">For the given TXGPUCanvas component, returns the value of the named numeric parameter as an array&nbsp;</font></li><li>function&nbsp; &nbsp;GetGPUConstIntValue(GPUName,pName:String):integer;&nbsp; <font color="#0000ff">&nbsp;For the given TXGPUCanvas component, returns the value of the named integer parameter&nbsp;</font></li><li>procedure SetGPUParamNumValue(GPUName,pName:String;pValue:TNumArray);&nbsp;&nbsp;<font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named numeric parameter as a 1-D array&nbsp;</font></li><li>procedure SetGPUParam2DNumValue(GPUName,pName:String;pValue:T2DNumArray);&nbsp; &nbsp;<font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named numeric parameter as a 2-D array&nbsp;</font></li><li>procedure SetGPUConstIntValue(GPUName,pName:String;pValue:integer);&nbsp; &nbsp; <font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named integer parameter&nbsp;</font></li><li>function&nbsp; &nbsp;GetGPUPixelArray(GPUName:String):T3DNumArray;&nbsp;&nbsp;<font color="#0000ff">&nbsp;Fetch the current Pixel array for the given TXGPUCanvas component&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;GetGPUPixelArrayAsString(GPUName:String):String;&nbsp;&nbsp;<font color="#0000ff">Fetch the current Pixel array in string format for the given TXGPUCanvas component&nbsp;</font>&nbsp;</li><li>function&nbsp; &nbsp;GetGPUStageArray(GPUName:String):T3DNumArray;&nbsp;&nbsp;&nbsp;<font color="#0000ff"> Fetch the stage array (resulting from the non-graphical kernel stack) for the given </font>TXGPUCanvas component&nbsp;&nbsp;</li><li>function&nbsp; &nbsp;GetGPUStageArrayAsString(GPUName:String):String;&nbsp; &nbsp;<font color="#0000ff">Fetch the stage array in string format for the given TXGPUCanvas component&nbsp;&nbsp;</font></li></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><h3>&nbsp;<u>Python Only</u></h3><ul><li>function&nbsp; ShowPythonPlot(ImgName,fig)<font color="#0000ff">&nbsp; In the given TXImage component, displays the contents of fig (a matplotlib figure)&nbsp;</font></li></ul><p><b>Project Development and Deployment</b></p><p>During the development phase of a project XIDE&nbsp;will usually be loaded in design mode where you can edit the user interface design and the code behind it. On startup on the desktop, the IDE re-loads the project you were last working on. On the browser, it can be set to revert to the original state every time the app is started or to reload from the previous session.</p><p>Existing projects can be loaded from a previously saved system in local storage, or from the clipboard. Clearing the current system will start a new project. At the end of the design phase, you will sometimes want to deploy the developed HTML app to end users without allowing access to the IDE. In this case, select the "System / Deploy" option from the main menu and this will generate a self contained HTML page implementing your application and the run time environment needed to execute it, but with the interactive IDE features disabled. You can now load this to a server of your choice, or email directly to your end user so they can run it from their file system.&nbsp;</p><p>Alternatively, if you wish to give them access to inspect and perhaps contribute to, or modify, the app, then distribute the blank XIDE app for their preferred platform&nbsp; and use the "System / Save" option to generate a project definition file that they can load into it using the "System / Load" option on the main menu.&nbsp;</p><p><b>Debugging</b></p><p>When testing Pascal code you have written using XIDE, the PAS2JS compiler error messages will flag any source code syntax problems. If you click on one of these error messages this will position the cursor at the relevant character position in the line of code in the XIDE&nbsp;code editor. Run time errors will sometimes be trapped by error handlers built in to XIDE&nbsp;and generate a helpful error message. If this is not sufficient to uniquely identify the cause of the problem then "ctrl shift J" in Chrome will bring up the built in developer console which will hopefully provide the additional information you need to track down the problem. Alternatively, a break point can be set in the code by inserting a "DebugStart;" instruction that will start the native browser debug facility at that point.</p><h3>Implementation, Extensibility and Licensing<br></h3><p>XIDE is implemented using the Pas2JS dialect of the Object Pascal programming language. This is because it is efficient, easy to learn, and is available on a wide range of processor architectures.&nbsp;</p><p>Sometimes, as projects go through their life cycle, new more specialist requirements emerge. At this point the XIDE framework can be extended using project or platform specific custom components developed in Lazarus.&nbsp;</p><p>XIDE is an open source project distributed using the same licence as Lazarus (GPL) Source code is available from GitHub&nbsp; see <a href="https://github.com/Steve--W/XIDE">here</a> for the IDE and&nbsp;<a href="https://github.com/Steve--W/XComponents">here</a> for the components used to build it. (see <font color="#0000ff">https://github.com/Steve--W/XIDE</font> and<font color="#0000ff"> https://github.com/Steve--W/XComponents</font> respectively)</p><h3>Development Roadmap</h3><p>I have developed XIDE&nbsp; to support my ongoing academic research projects. I have made the project open source in case it should prove useful to anyone else. In particular, I hope its browser first approach, low installation overhead and easy learning curve will help to introduce the&nbsp; joys of Free Pascal and Lazarus to a wider audience.<br></p><p>Those aspects of XIDE and XComponents that I use regularly are "tried and tested". Some aspects that are used less often may have more bugs, and there are many aspects where it would be great to add new or improved features but where I do not have the bandwidth to address at the moment. If&nbsp; anyone wants to help out with any improvement to XIDE then their contribution will be most welcome.</p><p>(Some topics that spring to mind, from a long list of potential improvements, are:-&nbsp; XIDE integration with Lazarus, improving the wrapper for GPUJS or adding a drag and drop utility for constructing MatPlotLib data visualisations to make these Python libraries easily accessible to the Pascal community. )</p><h3>Compatibility</h3><p>In desktop mode, XIDE is designed to run on platforms supported by&nbsp; Lazarus, and optionally, the&nbsp; Chromium Embedded Framework and&nbsp; Python (i.e. most desktop platforms). If CEF or Python is not available then XIDE can still run but will then not support their specialist features.&nbsp; Alternatively, Electron or Cordova and Crosswalk can be used to provide a hybrid implementation of XIDE. This gives full Web connectivity and CSS on a wide range of platforms but with a trade off in terms of size, speed and security.</p><p>In browser mode XIDE is targeting closed user groups (where the browser can be specified) so it is only tested on recent versions of Chrome but it may also work on other browsers which use a Chrome engine. (e.g. the latest version of Microsoft Edge)&nbsp;</p><p>Note that the Style Designer is only available on the Browser versions as it depends on CSS functionality.</p><h3>Motivation for including a GPU capability in XIDE</h3><p>XIDE provides a thin wrapper for GPUJS (See https://gpu.rocks/) which generates GPU code from JavaScript. This produces WebGL code as it is widely supported "out of the box"&nbsp; in most browsers and on most processor/GPU combinations. This minimises the&nbsp; installation and configuration needed in order to get GPU code running on a new system. As such it is a good way to start learning about the possibilities (and perhaps more importantly the limitations) of programming for a massively parallel platform.&nbsp;</p><p>One of the weaknesses of this approach is the frustrating inability to optimise code or diagnose bugs in the GPU kernels except by exhaustive trial and error.&nbsp; So for any serious GPU programming it is well worth investing the time in getting to grips with the (admittedly intimidating) learning curve needed to master tools like OpenCL or Cuda and the associated tool stacks. Having said that, for simple "embarrassingly parallel" examples, or where there is a need to build simple GPU code into more general purpose or widely shared apps, the GPUJS approach can be very helpful.</p><h3>The XIDE GPUJS Wrapper</h3><p>The Pascal code for the GPU is accessed as a property of a GPU Canvas component which has been dropped onto the User Interface layout screen and/or as a node on the Code designer tree.&nbsp; The Pascal GPU code editor follows the same edit/compile cycle as for user code in the rest of the system. The differences are that this is code for blocks of threads in parallel. The code describes a single instruction multiple data (SIMD) approach where all the threads run the same code with thread specific code referencing "this.thread.x" , "this.thread.y" and "this.thread.z" to reflect their position in the block of threads. Parameter names are declared using a Paramlist property of the GPU canvas component and their transfer and run time execution is controlled by system calls described below. (N.B. parameters need to be passed as arrays so even scalar parameters passed into the code need to be referenced as follows "myParam[0]" )<br></p><p>The Pascal GPU code can daisy chain kernels. (Set the TXGPUCanvas property NumKernels&gt;0) For each kernel in the chain its return value must be set to "MyValue". The next kernel in the chain can then read all the thread return values from the previous kernel by reading from "MyArray".The initial "MyArray" passed to the first kernel in the chain is set as a property ("InitStageData") of the GPU canvas and can have any x,y,z sizes as chosen by the user. The final&nbsp; &nbsp;kernel is the graphics display kernel where you set the r,g,b values as usual. The calculated data input to the graphics display kernel can also be accessed using either the "GetGPUStageArray" or "GetGPUStageArrayAsString" instructions;</p><p>Maths functions available in the GPU code are as follows:-</p><p></p><ul><li>abs(a) sign(a) trunc(a) ceil(a) max(a,b) min(a,b)</li><li>sin(a) cos(a) arcsin(a) arccos(a) arctan(a,b)</li><li>sqrt(a) power(a,b) ln(a) log10(a) log2(a)&nbsp;</li></ul><h3>Limitations of coding for the GPU&nbsp;</h3><p>When coding in Pascal for the GPU, you should be aware that there are fundamental limitations on the constructs available. In particular:-</p><p></p><ul><li>All parameters passed into the GPU&nbsp; are real arrays (scalar parameters are real arrays of length one)<br></li><li>You can read from but not write to any of these array parameters</li><li>You cannot declare a local array</li><li>Each thread returns a single real value</li><li>You cannot communicate with any other thread (except by synchronising the results in a new kernel)</li><li>You cannot use a Boolean type (use 0 or 1 instead)</li><li>You cannot use "var" parameters in a function call</li><li>All function parameters must be a simple type</li><li>Nested function declarations do not follow normal (Pascal) scope rules</li><li>Loops are unrolled so you MUST SET the "<span style="font-family: Verdana, Arial, sans-serif; font-size: 12px; white-space: nowrap;">MaxIterations"</span>&nbsp;parameter at a high enough value to reflect your algorithm''s requirements</li><li>The number of threads in each kernel are given by the KernelXDims, KernelYDims and Kernel ZDims properties of the GPU Canvas and these MUST BE SET either manually or programatically before activating the GPU.</li><li>The GPU is a Single Instruction Multiple Data machine so branching in a thread does not jump over the code in the path not taken,&nbsp; it idles in order to allow other threads to execute the code in that path if need be.&nbsp;</li><li>Debugging on the GPU is "primitive" the only way to do it when running on the hardware is to write out intermediate results&nbsp; to the thread output value for selected threads which you dedicate to providing diagnostic output.&nbsp;</li></ul><p><br></p><p><br></p><p></p>';

{ TXIDEHelpForm }

{$ifndef JScript}
procedure TXIDEHelpForm.FormCreate(Sender: TObject);
begin
  myNode:=DoXFormCreated(self);
  HelpFormRoot:=FindDataNodeById(myNode,'HelpFormVBox1','',true);

  HelpHTMLText.SourceText:=BaseHTML;

end;

procedure TXIDEHelpForm.FormActivate(Sender: TObject);
begin
end;

procedure TXIDEHelpForm.FormResize(Sender: TObject);
begin
  DoFormResize(self, HelpFormVBox1);
end;

procedure TXIDEHelpForm.FormShow(Sender: TObject);
begin
  HelpHTMLText.SourceText:=HelpHTMLText.SourceText;
end;
{$endif}


procedure TXIDEHelpForm.InitialiseonShow;
var
  txt:String;
begin
  self.Top:=100;
  self.Left:=150;
  {$ifdef JScript}
  // reset overview text AFTER the popup is rendered, otherwise actual height and width return 0
  asm
    var ob=this.HelpHTMLText;
    setTimeout(function(){pas.XHTMLText.ResetHTMLText(ob.NodeName,ob.NameSpace); }, 200);
  end;
  {$endif}
end;

end.

