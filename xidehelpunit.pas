(*
    Copyright (c) 2020  Steve Wright

    This unit is part of the XIDE project.

    This project is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

 **********************************************************************
 *)
unit XIDEHelpUnit;
{$ifndef JScript}
{$mode objfpc}{$H+}
{$endif}

interface

uses
  Classes, SysUtils, StringUtils, NodeUtils, XForm,
  {$ifndef JScript}
  Forms, Controls, Dialogs,LazsUtils, Events, IpHTML,
//    {$ifdef Chromium}
//    uCEFChromium, uCEFWindowParent, uCEFInterfaces, uCEFConstants, uCEFTypes, uCEFChromiumEvents,
//    {$endif}
  {$else}
  HTMLUtils,
  {$endif}
  WrapperPanel, XVBox, XHBox, XMemo, XButton,
  XLabel, XEditBox
  , EventsInterface, XHTMLText, XScrollBox, XHTMLEditor;

type

  { TXIDEHelpForm }

  TXIDEHelpForm = class(TXForm)
    HelpFormVBox1: TXVBox;
    HelpHTMLText: TXHTMLText;
    XIDEHelpScrollBox: TXScrollBox;
    {$ifndef JScript}
    procedure FormActivate(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormResize(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure LoadNewText(Data: PtrInt);
    {$endif}
  private

  public
     procedure InitialiseonShow;
  end;

var
  XIDEHelpForm: TXIDEHelpForm;
  HelpFormRoot:TDataNode;

implementation
uses
  XObjectInsp;

{$R *.lfm}

const BaseHtml =
//'<h1 style="text-align: center;"><u>Overview</u></h1><h2 style="text-align: center;">&nbsp;(Helping people write simple apps that work "everywhere")</h2><h3>Purpose</h3><p>XIDE is a combined Development and Run Time Environment designed to work in exactly the same way in&nbsp; Chrome,Linux,Windows or Android modes with as close to zero installation or learning curve as possible. The initial target applications are small "in house"client side, embedded or exploratory apps where the focus is on specialist functionality and rapid development or collaborative working with cosmetic aspects of the design such as style and speed being a secondary consideration. At the moment, it is not intended as a tool to develop web pages that are widely distributed to the general public although it can be used for prototyping these.</p><h3>Functionality</h3><p>In order to ensure that any project developed with&nbsp; XIDE will run unmodified in all other environments, its core components only supports that subset of functionality that exists on all platforms. This is typically that found in the browser as this for security reasons is the most restrictive environment. However XIDE is also designed to be easily extensible in order to support user specific projects or hardware requirements that do not need this portability.&nbsp;</p><p>If browser specific functionality (e.g. CSS or SVG) is required by the user then this can be provided by&nbsp; desktop versions of the IDE if the Chromium Embedded Framework (CEF) is supported for that implementation.&nbsp;</p><h3>Unified User Interface</h3><p>The browser supports a number of different standards as part of its user interface. These include HTML, CSS, SVG&nbsp;and GPU to cover page layout, style editing, vector graphics and graphics programming respectively. These all require their own conventions to be used when accessed directly from the browser and/or JavaScript.</p><p>XIDE unifies the users access to these different browser capabilities using a standardised Object Inspector / Drag and Drop approach for them all. For HTML and SVG this should appear seamless to the user with all the SVG containers and components accessed in an identical manner to HTML so requiring no further explanation than provided below for basic screen layout and editing.&nbsp;</p><h3>CSS Functionality</h3><p>CSS functionality is provided by supporting a style design tree in addition to the Code and UI design trees described below. As with the UI design tree, Style resources (new design rules, targets, properties and rule types ) are dragged from a resources tree and dropped on the relevant node of the style tree. The style tree also supports logical grouping of targets using "AND" and "OR" nodes.&nbsp; This speeds up and simplifies the CSS syntax generation considerably compared to direct text entry.</p><h3>GPU Code</h3><p>The GPU code capability would normally require a separate development environment and a different language to support development of code. XIDE encapsulates the complexities of WebGL by transpiling from (a subset of) pascal into WebGL / JavaScript code. WebGL has been chosen rather than say CUDA or OpenCL et. as WebGL is widely supported "out of the box"&nbsp; in most browsers and on most processor/GPU combinations. As such it minimises the&nbsp; installation and configuration needed in order to get XIDE running on a new system.</p><p>The Pascal code for the GPU is accessed as a property of a GPU Canvas component which has been dropped onto the User Interface layout screen and/or as a node on the Code designer tree.&nbsp; The Pascal GPU code editor follows the same edit/compile/debug cycle as for user code in the rest of the system. The differences are that this is code for blocks of threads in parallel. The code describes a single instruction multiple data (SIMD) approach where all the threads run the same code with thread specific code referencing "this.x" and "this.y" to reflect their position in the block of threads. Parameter names are declared using a Paramlist property of the GPU canvas component and their transfer and run time execution is controlled by system calls described below. (N.B. parameters need to be passed as arrays so even scalar parameters passed into the code need to be referenced as follows "myParam[0]" )</p><p>At this time, the subset of pascal functionality supported by&nbsp; the GPU is limited and no support is provided for the many sophisticated code optimisation options provided by specialist GPU programming environments. As such this capability is aimed at problems that can be made "embarrassingly parallel".<br></p><h3>Designing a User Interface<br></h3><p><b>Resource and Instance trees</b></p><p>XIDE uses a very simple paradigm. Essentially, it consists of three elements.</p><p></p><ol><li>&nbsp;A resources tree, showing the available widgets (visual and non visual)</li><li>&nbsp;A system design tree and object property inspector/editor</li><li>&nbsp;A layout panel showing a WYSIWYG version of the current page design.</li></ol><p></p> <p>The UI is built by pasting nodes from the resource tree to the system design tree.&nbsp;</p><p>Each node has object properties defined by a name/value pairs that can be edited using the object inspector or referenced and or updated by run time code.</p><p>Events are also available on each widget so that code can be attached to them using the built in code editor and compiler.&nbsp;</p><p>Each property can be bound to a selected data source at design time and code added to validate its status at run time. (Non visual components are dragged to the root node of the instance tree.)</p><p><b>Available widgets</b></p><p>The widgets listed in the resource tree include both UI and non visual components. The intention is that each widget is self documenting and that the set can be extended using third party contributions</p><p><b>Responsive Design</b></p><p>Web development has encouraged new and more flexible approaches to UI design. Unfortunately it has also led to an explosion of choice in this area. In practice this fragmentation creates new costs as well as benefits for our target user base. To counter this trend, XIDE only supports a simple responsive design layout paradigm.</p><p>In practice this consists of a Main page, Tab controls and Popups to define the constituent pages in a UI design. Horizontal and Vertical layout boxes (together with associated alignment properties) are then nested within these pages to control the final layout of components on the page.</p><p><b>Writing application code</b></p><p>XIDE uses an event driven model where event handlers written in Pascal can be attached to pre defined events triggered by objects in the user interface. These procedures can be inspected and/or edited by using the object inspector to navigate to the required UI object then pressing the ellipsis button to the right of the required event in its events tab. This creates an entry for that event handler under the "Event Handlers"node in the code design tree. So once a handler has been added it can then also be navigated to by selecting it in the code designer and pressing the edit button.</p><p><b>Pascal Syntax</b></p><p>The Pascal syntax recognised by XIDE&nbsp;is that used by the Pas2JS variant of Free Pascal. (http://wiki.freepascal.org/pas2js) A detail description of the supported syntax can be found here. (http://wiki.freepascal.org/pas2js#RTL)</p><p><b>Unit Structure</b></p><p>Shared code can be written by adding units, procedures and functions directly to the code design tree. This allows some automation of routine tasks and simplifies the user"s access to others such as binding.&nbsp;</p><p>To allow maximum flexibility, it is also possible to add standard Pascal units developed elsewhere as "Raw Units" These must have the "Interface"unit added to their uses clause in order to be able to access the XIDE&nbsp;API. In addition, they can access any of the standard set of PAS2JS run time library units. (http://wiki.freepascal.org/pas2js#RTL) Any other required units must be imported into XIDE&nbsp;as additional "Raw Units"before they can be referenced.</p><p><b>Accessing user interface objects at run time</b></p><p>XIDE is designed to be a cross platform rapid application development system. In order to do this it uses a text based system description tree (The System Design or instance tree) to reflect the state of a users program at all time. This is similar to the function of the Document Object Model (DOM) in standard web applications.</p> <p><b>Types of API Calls</b></p><p>In XIDE&nbsp;the instance tree describing a users project can be inspected manually using the Object Inspector. This allows the user to select any node on the tree and inspect and/or modify its properties or event handlers as required. The XIDE&nbsp;API allows the same actions to be available programmatically. This ability to generate events using code is particularly useful in automated testing, asynchronous call back functions, or multi threading applications. The functions available fall into eight types viz:-</p><p></p><ul><li>&nbsp;Dialog boxes</li><li>&nbsp;Get and/or set a property value of a UI object</li><li>&nbsp;Save and load user selected data to the clipboard</li><li>&nbsp;copy or delete a UI component or move it to a new parent.</li><li>&nbsp;Add to, or replace, the event response for a UI object and/or trigger such an event artificially</li><li>&nbsp;Show or hide a popup form.</li><li>&nbsp;Show or hide a busy indicator.</li><li>&nbsp;get and set GPU parameters (integer,number and image)</li></ul><p></p><p>The detail syntax for these function calls is appended below. Note that unless explicitly stated, all values are either strings or string arrays.</p><p><b>Asynchronous Calls, Multi Threading and Initialization functions</b></p><p>Many web calls issue requests that need to wait for a response from a web service, database or other remote service provider. Similarly, when starting another thread in parallel, the main thread will often need to wait for such child threads to return the results of their work before it can proceed. XIDE&nbsp;allows main event handlers to specify a "initalisation"function. This is a block of code which issues all such requests prior to running the main event code when they have all finished executing. See below for the detail syntax of the available calls.</p><p>Note however that all such asynchronous calls first parameter is "e"the event context (automatically declared and populated by Xide, behind the scenes, for every XIDE&nbsp;event) from which they have been issued so they know where to return without requiring the user to enter complex boilerplate code.</p><p><b>List of&nbsp;XIDE&nbsp;specific API procedure and function calls</b></p> <p></p><ul><li>Procedure showMessage(TextMessage:string);</li><li>Procedure consoleLog(TextMessage:string);</li><li>Function&nbsp; confirm(TextMessage:string):boolean;</li><li>Function&nbsp; prompt(TextMessage,promptString:string):string;</li><li>Procedure setPropertyValue(nodeName:String;propName:String;newValue:String);</li><li>Procedure setPropertyValueIndexed(nodeName:String;propName:String;newValue:TStringArray; x,y:integer);</li><li>Function&nbsp; getPropertyValue(nodeName:String;propName:String):string;</li><li>Function&nbsp; getPropertyValueIndexed(nodeName:String;propName:String; x,y,w,h:integer):TstringArray; <i>// When accessing array properties, "x" and "y" are the index positions for the top left position for the range to start. "w" and "h" are the width and height of the range. The type TStringArray is declared in pascal as&nbsp; "My string array = Array of String;"&nbsp; when accesed as a string it"s format is [["a","b","c"......"z"],["1","2","3"....."9"],....[...etc....]]</i></li><li>Procedure copyToClip(str:String);<i> //Place the string on the clipboard&nbsp;</i></li><li>Procedure copyFromClip(e); <i>// Fetch text from clipboard (note that this is an async operation so this line of code can only appear in an initialization tab of an event procedure. After this has executed the main event code tab can access the result using the parameter e.returnString )</i></li><li>Procedure copycomponent(NodeToBeCopied,NewParentId,NewNodeID:string);</li><li>Function&nbsp; deletecomponent(NodeID:string):boolean; <i>// this returns true if the operation succeeds in deleteing the node (i.e. it existed and has been deleted)</i></li><li>Procedure moveComponent(nodeId,NewParentId:string);<i>// Re-parent the given XIDE component&nbsp;</i></li><li>Procedure doEvent(EventType,NodeId,myValue:string);<i> //Execute the event code for the given XIDE event type. To modify the response to an exiting event add an "EventTrapper" component to the system this will see the full event stream&nbsp; allowing you to filter this for the event of interest and code the appropriate additional action.&nbsp; Available information on each event consists of the following system defined variables. "e.EventType, e.NodeId, e.eventvalue : string;" to then continue to run the default event code, set "e.ContinueAfterTrappers = true;" at the end of the event handler&nbsp;</i></li><li>Procedure showXForm(XFormID:String; modal:Boolean);</li><li>Procedure closeXForm(XFormID:String);</li><li>Procedure showBusy;</li><li>Procedure hideBusy;</li><li>Function&nbsp; getGpuPramNumValue(GPUName,pName:String):number;&nbsp;&nbsp;</li><li>Function&nbsp; getGpuConstIntValue(GPUName,pName:String):integer;&nbsp;&nbsp;</li><li>Function&nbsp; getGpuParamImgValue(GPUName,pName:String):TImgArray;&nbsp;&nbsp;</li><li>Procedure setGpuParamNumValue(GPUName,pName:String;pValue:number);</li><li>Procedure setGpuConstIntValue(GPUName,pName:String;pValue:integer);</li><li>Procedure setGpuParamImgValue(GPUName,pName:String;pValue:TImgArray);&nbsp;</li></ul><p><b>App Development and Deployment</b></p><p>During the development phase of a project XIDE&nbsp;will usually be loaded in interactive app design mode where you can edit the user interface design and the code behind it. Here by default, the IDE re-loads the project you were last working on.&nbsp;</p><p>New projects can be started by clearing the current system or loading a previously saved system from the clipboard. This behaves the same in native host environments (Windows or Linux) as it does in Chrome or Android. At the end of this phase, you will sometimes want to deploy the developed app to end users without allowing access to the IDE. In this case, select the "System / Deploy" option from the main menu and this will generate a self contained HTML page implementing your application and the run time environment needed to execute it, but with the interactive IDE features disabled. You can now load this to a server of your choice, or email directly to your end user so they can run it from their file system.&nbsp;</p><p>Alternatively, if you wish to give them access to inspect and perhaps contribute to, or modify, the app, then distribute the blank XIDE app for their preferred platform (Chrome / Linux / Windows / Android) and use the "System / Save" option to generate a app definition file that they can load into it using the "System / Load" option on the main menu.&nbsp;</p><p><b>Debugging</b></p><p>When testing Pascal code you have written using XIDE, the PAS2JS compiler error messages will flag any source code syntax problems. If you click on one of these error messages this will position the cursor at the relevant character position in the line of code in the XIDE&nbsp;code editor. Run time errors will sometimes be trapped by error handlers built in to XIDE&nbsp;and generate a helpful error message. If this is not sufficient to uniquely identify the cause of the problem then "ctrl shift J" in Chrome will bring up the built in developer console which will hopefully provide the additional information you need to track down the problem.</p><h3>Implementation, Extensibility and Licensing<br></h3><p>XIDE is implemented using the Pas2JS dialect of the Object Pascal programming language. This is because it is efficient, easy to learn, and is available on a wide range of processor architectures.&nbsp;</p><p>Sometimes, as projects go through their life cycle, new more specialist requirements emerge. At this point the XIDE framework can be extended using project or platform specific custom components developed in Lazarus. Alternatively the HTML and JavaScript code generated by XIDE can be imported into a general-purpose web design tool stack to enable full enterprise level development.&nbsp;</p><p>XIDE is an open source project distributed using the same licence as Lazarus (GPL)</p><h3>Development Roadmap</h3><p>As an open source project, the future development of XIDE depends on how many collaborators choose to contribute to the project, and which aspects are most important to them.&nbsp;</p><p>The initial project has focused on functionality rather than style or speed, and on the ability to operate as a fully self contained IDE with the minimum of dependencies.&nbsp;</p><p>As the project matures, it is hoped that new collaborators may add web connectivity, database access, comprehensive style support, support for other operating systems (eg IOS) or browsers other than Chrome.&nbsp;</p><h3>Compatibility</h3><p>In desktop mode, XIDE is designed to run on platforms supported by Lazarus and the Chromium Embedded Framework (i.e. most desktop platforms). If the latter is not available then XIDE can still run but will then not support SVG or other embedded browser features.&nbsp;</p><p>In browser mode XIDE should run on any up to date HTML5 enabled browser. However as it is targeting closed user groups (where the browser can be specified)&nbsp; it is only tested on recent versions of Chrome.&nbsp;</p><p>Alternatively, Electron or Cordova and Crosswalk can be used to provide a hybrid implementation of XIDE. This gives full Web connectivity and CSS on a wide range of platforms but with a trade off in terms of size,speed and security.</p><p><br></p><p></p>';
//'<h1 style="text-align: center;"><u>Overview</u></h1><h2 style="text-align: center;">&nbsp;(Helping people write simple apps that work "everywhere")</h2><h3>Purpose</h3><p>XIDE is a combined Development and Run Time Environment designed to work in exactly the same way in&nbsp; Chrome,Linux,Windows or Android modes with as close to zero installation or learning curve as possible. The initial target applications are small "in house"client side, embedded or exploratory apps where the focus is on specialist functionality and rapid development or collaborative working with cosmetic aspects of the design such as style and speed being a secondary consideration. At the moment, it is not intended as a tool to develop web pages that are widely distributed to the general public although it can be used for prototyping these.</p><h3>Functionality</h3><p>In order to ensure that any project developed with&nbsp; XIDE will run unmodified in all other environments, its core components only supports that subset of functionality that exists on all platforms. This is typically that found in the browser as this for security reasons is the most restrictive environment. However XIDE is also designed to be easily extensible in order to support user specific projects or hardware requirements that do not need this portability.&nbsp;</p><p>If browser specific functionality (e.g. CSS or SVG) is required by the user then this can be provided by&nbsp; desktop versions of the IDE if the Chromium Embedded Framework (CEF) is supported for that implementation.&nbsp;</p><h3>Unified User Interface</h3><p>The browser supports a number of different standards as part of its user interface. These include HTML, CSS, SVG&nbsp;and GPU to cover page layout, style editing, vector graphics and graphics programming respectively. These all require their own conventions to be used when accessed directly from the browser and/or JavaScript.</p><p>XIDE unifies the users access to these different browser capabilities using a standardised Object Inspector / Drag and Drop approach for them all. For HTML and SVG this should appear seamless to the user with all the SVG containers and components accessed in an identical manner to HTML so requiring no further explanation than provided below for basic screen layout and editing.&nbsp;</p><h3>CSS Functionality</h3><p>CSS functionality is provided by supporting a style design tree in addition to the Code and UI design trees described below. As with the UI design tree, Style resources (new design rules, targets, properties and rule types ) are dragged from a resources tree and dropped on the relevant node of the style tree. The style tree also supports logical grouping of targets using "AND" and "OR" nodes.&nbsp; This speeds up and simplifies the CSS syntax generation considerably compared to direct text entry.</p><h3>GPU Code</h3><p>The GPU code capability would normally require a separate development environment and a different language to support development of code. XIDE encapsulates the complexities of WebGL by transpiling from (a subset of) pascal into WebGL / JavaScript code. WebGL has been chosen rather than say CUDA or OpenCL et. as WebGL is widely supported "out of the box"&nbsp; in most browsers and on most processor/GPU combinations. As such it minimises the&nbsp; installation and configuration needed in order to get XIDE running on a new system.</p><p>The Pascal code for the GPU is accessed as a property of a GPU Canvas component which has been dropped onto the User Interface layout screen and/or as a node on the Code designer tree.&nbsp; The Pascal GPU code editor follows the same edit/compile/debug cycle as for user code in the rest of the system. The differences are that this is code for blocks of threads in parallel. The code describes a single instruction multiple data (SIMD) approach where all the threads run the same code with thread specific code referencing "this.x" and "this.y" to reflect their position in the block of threads. Parameter names are declared using a Paramlist property of the GPU canvas component and their transfer and run time execution is controlled by system calls described below. (N.B. parameters need to be passed as arrays so even scalar parameters passed into the code need to be referenced as follows "myParam[0]" )</p><p>At this time, the subset of pascal functionality supported by&nbsp; the GPU is limited and no support is provided for the many sophisticated code optimisation options provided by specialist GPU programming environments. As such this capability is aimed at problems that can be made "embarrassingly parallel". See https://gpu.rocks/ for full details of the underlying JavaScript to webGL transpiler technology (N.B. Our releases lag theirs so some of the features described may not be available yet in our version)<br></p><h3>Designing a User Interface<br></h3><p><b>Resource and Instance trees</b></p><p>XIDE uses a very simple paradigm. Essentially, it consists of three elements.</p><p></p><ol><li>&nbsp;A resources tree, showing the available widgets (visual and non visual)</li><li>&nbsp;A system design tree and object property inspector/editor</li><li>&nbsp;A layout panel showing a WYSIWYG version of the current page design.</li></ol><p></p> <p>The UI is built by pasting nodes from the resource tree to the system design tree.&nbsp;</p><p>Each node has object properties defined by a name/value pairs that can be edited using the object inspector or referenced and or updated by run time code.</p><p>Events are also available on each widget so that code can be attached to them using the built in code editor and compiler.&nbsp;</p><p>Each property can be bound to a selected data source at design time and code added to validate its status at run time. (Non visual components are dragged to the root node of the instance tree.)</p><p><b>Available widgets</b></p><p>The widgets listed in the resource tree include both UI and non visual components. The intention is that each widget is self documenting and that the set can be extended using third party contributions</p><p><b>Responsive Design</b></p><p>Web development has encouraged new and more flexible approaches to UI design. Unfortunately it has also led to an explosion of choice in this area. In practice this fragmentation creates new costs as well as benefits for our target user base. To counter this trend, XIDE only supports a simple responsive design layout paradigm.</p><p>In practice this consists of a Main page, Tab controls and Popups to define the constituent pages in a UI design. Horizontal and Vertical layout boxes (together with associated alignment properties) are then nested within these pages to control the final layout of components on the page.</p><p><b>Writing application code</b></p><p>XIDE uses an event driven model where event handlers written in Pascal can be attached to pre defined events triggered by objects in the user interface. These procedures can be inspected and/or edited by using the object inspector to navigate to the required UI object then pressing the ellipsis button to the right of the required event in its events tab. This creates an entry for that event handler under the "Event Handlers"node in the code design tree. So once a handler has been added it can then also be navigated to by selecting it in the code designer and pressing the edit button.</p><p><b>Pascal Syntax</b></p><p>The Pascal syntax recognised by XIDE&nbsp;is that used by the Pas2JS variant of Free Pascal. (http://wiki.freepascal.org/pas2js) A detail description of the supported syntax can be found here. (http://wiki.freepascal.org/pas2js#RTL)</p><p><b>Unit Structure</b></p><p>Shared code can be written by adding units, procedures and functions directly to the code design tree. This allows some automation of routine tasks and simplifies the user"s access to others such as binding.&nbsp;</p><p>To allow maximum flexibility, it is also possible to add standard Pascal units developed elsewhere as "Raw Units" These must have the "Interface"unit added to their uses clause in order to be able to access the XIDE&nbsp;API. In addition, they can access any of the standard set of PAS2JS run time library units. (http://wiki.freepascal.org/pas2js#RTL) Any other required units must be imported into XIDE&nbsp;as additional "Raw Units"before they can be referenced.</p><p><b>Accessing user interface objects at run time</b></p><p>XIDE is designed to be a cross platform rapid application development system. In order to do this it uses a text based system description tree (The System Design or instance tree) to reflect the state of a users program at all time. This is similar to the function of the Document Object Model (DOM) in standard web applications.</p> <p><b>Types of API Calls</b></p><p>In XIDE&nbsp;the instance tree describing a users project can be inspected manually using the Object Inspector. This allows the user to select any node on the tree and inspect and/or modify its properties or event handlers as required. The XIDE&nbsp;API allows the same actions to be available programmatically. This ability to generate events using code is particularly useful in automated testing, asynchronous call back functions, or multi threading applications. The functions available fall into eight types viz:-</p><p></p><ul><li>&nbsp;Dialog boxes</li><li>&nbsp;Get and/or set a property value of a UI object</li><li>&nbsp;Save and load user selected data to the clipboard</li><li>&nbsp;copy or delete a UI component or move it to a new parent.</li><li>&nbsp;Add to, or replace, the event response for a UI object and/or trigger such an event artificially</li><li>&nbsp;Show or hide a popup form.</li><li>&nbsp;Show or hide a busy indicator.</li><li>&nbsp;get and set GPU parameters (integer,number and image)</li></ul><p></p><p>The detail syntax for these function calls is appended below. Note that unless explicitly stated, all values are either strings or string arrays.</p><p><b>Asynchronous Calls, Multi Threading and Initialization functions</b></p><p>Many web calls issue requests that need to wait for a response from a web service, database or other remote service provider. Similarly, when starting another thread in parallel, the main thread will often need to wait for such child threads to return the results of their work before it can proceed. XIDE&nbsp;allows main event handlers to specify a "initalisation"function. This is a block of code which issues all such requests prior to running the main event code when they have all finished executing. See below for the detail syntax of the available calls.</p><p>Note however that all such asynchronous calls first parameter is "e"the event context (automatically declared and populated by Xide, behind the scenes, for every XIDE&nbsp;event) from which they have been issued so they know where to return without requiring the user to enter complex boilerplate code.</p><p><b>List of&nbsp;XIDE&nbsp;specific API procedure and function calls</b></p> <p></p><ul><li>Procedure showMessage(TextMessage:string);</li><li>Procedure consoleLog(TextMessage:string);</li><li>Function&nbsp; confirm(TextMessage:string):boolean;</li><li>Function&nbsp; prompt(TextMessage,promptString:string):string;</li><li>Procedure setPropertyValue(nodeName:String;propName:String;newValue:String);</li><li>Procedure setPropertyValueIndexed(nodeName:String;propName:String;newValue:TStringArray; x,y:integer);</li><li>Function&nbsp; getPropertyValue(nodeName:String;propName:String):string;</li><li>Function&nbsp; getPropertyValueIndexed(nodeName:String;propName:String; x,y,w,h:integer):TstringArray; <i>// When accessing array properties, "x" and "y" are the index positions for the top left position for the range to start. "w" and "h" are the width and height of the range. The type TStringArray is declared in pascal as&nbsp; "My string array = Array of String;"&nbsp; when accesed as a string it"s format is [["a","b","c"......"z"],["1","2","3"....."9"],....[...etc....]]</i></li><li>Procedure copyToClip(str:String);<i> //Place the string on the clipboard&nbsp;</i></li><li>Procedure copyFromClip(e); <i>// Fetch text from clipboard (note that this is an async operation so this line of code can only appear in an initialization tab of an event procedure. After this has executed the main event code tab can access the result using the parameter e.returnString )</i></li><li>Procedure copycomponent(NodeToBeCopied,NewParentId,NewNodeID:string);</li><li>Function&nbsp; deletecomponent(NodeID:string):boolean; <i>// this returns true if the operation succeeds in deleteing the node (i.e. it existed and has been deleted)</i></li><li>Procedure moveComponent(nodeId,NewParentId:string);<i>// Re-parent the given XIDE component&nbsp;</i></li><li>Procedure doEvent(EventType,NodeId,myValue:string);<i> //Execute the event code for the given XIDE event type. To modify the response to an exiting event add an "EventTrapper" component to the system this will see the full event stream&nbsp; allowing you to filter this for the event of interest and code the appropriate additional action.&nbsp; Available information on each event consists of the following system defined variables. "e.EventType, e.NodeId, e.eventvalue : string;" to then continue to run the default event code, set "e.ContinueAfterTrappers = true;" at the end of the event handler&nbsp;</i></li><li>Procedure showXForm(XFormID:String; modal:Boolean);</li><li>Procedure closeXForm(XFormID:String);</li><li>Procedure showBusy;</li><li>Procedure hideBusy;</li><li>Function&nbsp; getGpuPramNumValue(GPUName,pName:String):number;&nbsp;&nbsp;</li><li>Function&nbsp; getGpuConstIntValue(GPUName,pName:String):integer;&nbsp;&nbsp;</li><li>Function&nbsp; getGpuParamImgValue(GPUName,pName:String):TImgArray;&nbsp;&nbsp;</li><li>Procedure setGpuParamNumValue(GPUName,pName:String;pValue:number);</li><li>Procedure setGpuConstIntValue(GPUName,pName:String;pValue:integer);</li><li>Procedure setGpuParamImgValue(GPUName,pName:String;pValue:TImgArray);&nbsp;</li></ul><p><b>App Development and Deployment</b></p><p>During the development phase of a project XIDE&nbsp;will usually be loaded in interactive app design mode where you can edit the user interface design and the code behind it. Here by default, the IDE re-loads the project you were last working on.&nbsp;</p><p>New projects can be started by clearing the current system or loading a previously saved system from the clipboard. This behaves the same in native host environments (Windows or Linux) as it does in Chrome or Android. At the end of this phase, you will sometimes want to deploy the developed app to end users without allowing access to the IDE. In this case, select the "System / Deploy" option from the main menu and this will generate a self contained HTML page implementing your application and the run time environment needed to execute it, but with the interactive IDE features disabled. You can now load this to a server of your choice, or email directly to your end user so they can run it from their file system.&nbsp;</p><p>Alternatively, if you wish to give them access to inspect and perhaps contribute to, or modify, the app, then distribute the blank XIDE app for their preferred platform (Chrome / Linux / Windows / Android) and use the "System / Save" option to generate a app definition file that they can load into it using the "System / Load" option on the main menu.&nbsp;</p><p><b>Debugging</b></p><p>When testing Pascal code you have written using XIDE, the PAS2JS compiler error messages will flag any source code syntax problems. If you click on one of these error messages this will position the cursor at the relevant character position in the line of code in the XIDE&nbsp;code editor. Run time errors will sometimes be trapped by error handlers built in to XIDE&nbsp;and generate a helpful error message. If this is not sufficient to uniquely identify the cause of the problem then "ctrl shift J" in Chrome will bring up the built in developer console which will hopefully provide the additional information you need to track down the problem.</p><h3>Implementation, Extensibility and Licensing<br></h3><p>XIDE is implemented using the Pas2JS dialect of the Object Pascal programming language. This is because it is efficient, easy to learn, and is available on a wide range of processor architectures.&nbsp;</p><p>Sometimes, as projects go through their life cycle, new more specialist requirements emerge. At this point the XIDE framework can be extended using project or platform specific custom components developed in Lazarus. Alternatively the HTML and JavaScript code generated by XIDE can be imported into a general-purpose web design tool stack to enable full enterprise level development.&nbsp;</p><p>XIDE is an open source project distributed using the same licence as Lazarus (GPL)</p><h3>Development Roadmap</h3><p>As an open source project, the future development of XIDE depends on how many collaborators choose to contribute to the project, and which aspects are most important to them.&nbsp;</p><p>The initial project has focused on functionality rather than style or speed, and on the ability to operate as a fully self contained IDE with the minimum of dependencies.&nbsp;</p><p>As the project matures, it is hoped that new collaborators may add web connectivity, database access, comprehensive style support, support for other operating systems (eg IOS) or browsers other than Chrome.&nbsp;</p><h3>Compatibility</h3><p>In desktop mode, XIDE is designed to run on platforms supported by Lazarus and the Chromium Embedded Framework (i.e. most desktop platforms). If the latter is not available then XIDE can still run but will then not support SVG or other embedded browser features.&nbsp;</p><p>In browser mode XIDE should run on any up to date HTML5 enabled browser. However as it is targeting closed user groups (where the browser can be specified)&nbsp; it is only tested on recent versions of Chrome.&nbsp;</p><p>Alternatively, Electron or Cordova and Crosswalk can be used to provide a hybrid implementation of XIDE. This gives full Web connectivity and CSS on a wide range of platforms but with a trade off in terms of size,speed and security.</p><p><br></p><p></p>';
'<h1 style="text-align: center;"><u>Overview</u></h1><h2 style="text-align: center;">&nbsp;(Helping people write simple apps that work "everywhere")</h2><h3>Purpose</h3><p>XIDE is a combined Development and Run Time Environment designed to work in exactly the same way in&nbsp; Chrome,Linux,Windows or Android modes with as close to zero installation or learning curve as possible. The initial target applications are small "in house"client side, embedded or exploratory apps where the focus is on specialist functionality and rapid development or collaborative working with cosmetic aspects of the design such as style and speed being a secondary consideration. At the moment, it is not intended as a tool to develop web pages that are widely distributed to the general public although it can be used for prototyping these.</p><h3>Functionality</h3><p>In order to ensure that any project developed with&nbsp; XIDE will run unmodified in all other environments, its core components only supports that subset of functionality that exists on all platforms. This is typically that found in the browser as this for security reasons is the most restrictive environment. However XIDE is also designed to be easily extensible in order to support user specific projects or hardware requirements that do not need this portability.&nbsp;</p><p>If browser specific functionality (e.g. CSS or SVG) is required by the user then this can be provided by&nbsp; desktop versions of the IDE if the Chromium Embedded Framework (CEF) is supported for that implementation.&nbsp;</p><h3>Unified User Interface</h3><p>The browser supports a number of different standards as part of its user interface. These include HTML, CSS, SVG&nbsp;and GPU to cover page layout, style editing, vector graphics and graphics programming respectively. These all require their own conventions to be used when accessed directly from the browser and/or JavaScript.</p><p>XIDE unifies the users access to these different browser capabilities using a standardised Object Inspector / Drag and Drop approach for them all. For HTML and SVG this should appear seamless to the user with all the SVG containers and components accessed in an identical manner to HTML so requiring no further explanation than provided below for basic screen layout and editing.&nbsp;</p><h3>CSS Functionality</h3><p>CSS functionality is provided by supporting a style design tree in addition to the Code and UI design trees described below. As with the UI design tree, Style resources (new design rules, targets, properties and rule types ) are dragged from a resources tree and dropped on the relevant node of the style tree. The style tree also supports logical grouping of targets using "AND" and "OR" nodes.&nbsp; This speeds up and simplifies the CSS syntax generation considerably compared to direct text entry.</p><h3>GPU Code</h3><p>The GPU code capability would normally require a separate development environment and a different language to support development of code. XIDE encapsulates the complexities of WebGL by transpiling from (a subset of) pascal into WebGL / JavaScript code. WebGL has been chosen rather than say CUDA or OpenCL et. as WebGL is widely supported "out of the box"&nbsp; in most browsers and on most processor/GPU combinations. As such it minimises the&nbsp; installation and configuration needed in order to get XIDE running on a new system.</p><p>The Pascal code for the GPU is accessed as a property of a GPU Canvas component which has been dropped onto the User Interface layout screen and/or as a node on the Code designer tree.&nbsp; The Pascal GPU code editor follows the same edit/compile/debug cycle as for user code in the rest of the system. The differences are that this is code for blocks of threads in parallel. The code describes a single instruction multiple data (SIMD) approach where all the threads run the same code with thread specific code referencing "this.x" and "this.y" to reflect their position in the block of threads. Parameter names are declared using a Paramlist property of the GPU canvas component and their transfer and run time execution is controlled by system calls described below. (N.B. parameters need to be passed as arrays so even scalar parameters passed into the code need to be referenced as follows "myParam[0]" )</p><p>The Pascal GPU code in a thread cannot access variables in other threads because these are all executed in an unspecified order depending on the specifics of the GPU available in the host and so allowing access would entail unacceptable race conditions. Instead you can synchronise the threads at a number of stages by daisy chaining kernels. (Set the TXGPUCanvas property NumKernels&gt;1) For each kernel in the chain its return value must be set to "MyValue". The next kernel in the chain can then read all the thread return values from the previous kernel by reading from "MyArray". The final kernel is the graphics display kernel where you set the r,g,b values as usual.</p><p>Maths functions available in the GPU code are as follows:-</p><p></p><ul><li>abs(a) sign(a) trunc(a) ceil(a) max(a,b) min(a,b)</li><li>sin(a) cos(a) arcsin(a) arccos(a) arctan(a,b)</li><li>sqrt(a) power(a,b) ln(a) log10(a) log2(a)&nbsp;</li></ul><p></p><p>At this time, the subset of pascal functionality supported by&nbsp; the GPU is limited and no support is provided for the many sophisticated code optimisation options provided by specialist GPU programming environments. As such this capability is aimed at problems that can be made "embarrassingly parallel". See https://gpu.rocks/ for full details of the underlying JavaScript to webGL transpiler technology (N.B. Our releases lag theirs so some of the features described may not be available yet in our version)<br></p><h3>Designing a User Interface<br></h3><p><b>Resource and Instance trees</b></p><p>XIDE uses a very simple paradigm. Essentially, it consists of three elements.</p><p></p><ol><li>&nbsp;A resources tree, showing the available widgets (visual and non visual)</li><li>&nbsp;A system design tree and object property inspector/editor</li><li>&nbsp;A layout panel showing a WYSIWYG version of the current page design.</li></ol><p></p> <p>The UI is built by pasting nodes from the resource tree to the system design tree.&nbsp;</p><p>Each node has object properties defined by a name/value pairs that can be edited using the object inspector or referenced and or updated by run time code.</p><p>Events are also available on each widget so that code can be attached to them using the built in code editor and compiler.&nbsp;</p><p>Each property can be bound to a selected data source at design time and code added to validate its status at run time. (Non visual components are dragged to the root node of the instance tree.)</p><p><b>Available widgets</b></p><p>The widgets listed in the resource tree include both UI and non visual components. The intention is that each widget is self documenting and that the set can be extended using third party contributions</p><p><b>Responsive Design</b></p><p>Web development has encouraged new and more flexible approaches to UI design. Unfortunately it has also led to an explosion of choice in this area. In practice this fragmentation creates new costs as well as benefits for our target user base. To counter this trend, XIDE only supports a simple responsive design layout paradigm.</p><p>In practice this consists of a Main page, Tab controls and Popups to define the constituent pages in a UI design. Horizontal and Vertical layout boxes (together with associated alignment properties) are then nested within these pages to control the final layout of components on the page.</p><p><b>Writing application code</b></p><p>XIDE uses an event driven model where event handlers written in Pascal can be attached to pre defined events triggered by objects in the user interface. These procedures can be inspected and/or edited by using the object inspector to navigate to the required UI object then pressing the ellipsis button to the right of the required event in its events tab. This creates an entry for that event handler under the "Event Handlers"node in the code design tree. So once a handler has been added it can then also be navigated to by selecting it in the code designer and pressing the edit button.</p><p><b>Pascal Syntax</b></p><p>The Pascal syntax recognised by XIDE&nbsp;is that used by the Pas2JS variant of Free Pascal. (http://wiki.freepascal.org/pas2js) A detail description of the supported syntax can be found here. (http://wiki.freepascal.org/pas2js#RTL)</p><p><b>Unit Structure</b></p><p>Shared code can be written by adding units, procedures and functions directly to the code design tree. This allows some automation of routine tasks and simplifies the user"s access to others such as binding.&nbsp;</p><p>To allow maximum flexibility, it is also possible to add standard Pascal units developed elsewhere as "Raw Units" These must have the "Interface"unit added to their uses clause in order to be able to access the XIDE&nbsp;API. In addition, they can access any of the standard set of PAS2JS run time library units. (http://wiki.freepascal.org/pas2js#RTL) Any other required units must be imported into XIDE&nbsp;as additional "Raw Units"before they can be referenced.</p><p><b>Accessing user interface objects at run time</b></p><p>XIDE is designed to be a cross platform rapid application development system. In order to do this it uses a text based system description tree (The System Design or instance tree) to reflect the state of a users program at all time. This is similar to the function of the Document Object Model (DOM) in standard web applications.</p> <p><b>Types of API Calls</b></p><p>In XIDE&nbsp;the instance tree describing a users project can be inspected manually using the Object Inspector. This allows the user to select any node on the tree and inspect and/or modify its properties or event handlers as required. The XIDE&nbsp;API allows the same actions to be available programmatically. This ability to generate events using code is particularly useful in automated testing, asynchronous call back functions, or multi threading applications. The functions available fall into eight types viz:-</p><p></p><ul><li>&nbsp;Dialog boxes</li><li>&nbsp;Get and/or set a property value of a UI object</li><li>&nbsp;Save and load user selected data to the clipboard</li><li>&nbsp;copy or delete a UI component or move it to a new parent.</li><li>&nbsp;Add to, or replace, the event response for a UI object and/or trigger such an event artificially</li><li>&nbsp;Show or hide a popup form.</li><li>&nbsp;Show or hide a busy indicator.</li><li>&nbsp;get and set GPU parameters (integer,number and image)</li></ul><p></p><p>The detail syntax for these function calls is appended below. Note that unless explicitly stated, all values are either strings or string arrays.</p><p><b>Asynchronous Calls, Multi Threading and Initialization functions</b></p><p>Many web calls issue requests that need to wait for a response from a web service, database or other remote service provider. Similarly, when starting another thread in parallel, the main thread will often need to wait for such child threads to return the results of their work before it can proceed. XIDE&nbsp;allows main event handlers to specify a "initalisation"function. This is a block of code which issues all such requests prior to running the main event code when they have all finished executing. See below for the detail syntax of the available calls.</p><p>Note however that all such asynchronous calls first parameter is "e"the event context (automatically declared and populated by Xide, behind the scenes, for every XIDE&nbsp;event) from which they have been issued so they know where to return without requiring the user to enter complex boilerplate code.</p><p><b>List of&nbsp;XIDE&nbsp;specific API procedure and function calls</b></p> <p></p><ul><li>Procedure showMessage(TextMessage:string);</li><li>Procedure consoleLog(TextMessage:string);</li><li>Function&nbsp; confirm(TextMessage:string):boolean;</li><li>Function&nbsp; prompt(TextMessage,promptString:string):string;</li><li>Procedure setPropertyValue(nodeName:String;propName:String;newValue:String);</li><li>Procedure setPropertyValueIndexed(nodeName:String;propName:String;newValue:TStringArray; x,y:integer);</li><li>Function&nbsp; getPropertyValue(nodeName:String;propName:String):string;</li><li>Function&nbsp; getPropertyValueIndexed(nodeName:String;propName:String; x,y,w,h:integer):TstringArray; <i>// When accessing array properties, "x" and "y" are the index positions for the top left position for the range to start. "w" and "h" are the width and height of the range. The type TStringArray is declared in pascal as&nbsp; "My string array = Array of String;"&nbsp; when accesed as a string it"s format is [["a","b","c"......"z"],["1","2","3"....."9"],....[...etc....]]</i></li><li>Procedure copyToClip(str:String);<i> //Place the string on the clipboard&nbsp;</i></li><li>Procedure copyFromClip(e); <i>// Fetch text from clipboard (note that this is an async operation so this line of code can only appear in an initialization tab of an event procedure. After this has executed the main event code tab can access the result using the parameter e.returnString )</i></li><li>Procedure copycomponent(NodeToBeCopied,NewParentId,NewNodeID:string);</li><li>Function&nbsp; deletecomponent(NodeID:string):boolean; <i>// this returns true if the operation succeeds in deleteing the node (i.e. it existed and has been deleted)</i></li><li>Procedure moveComponent(nodeId,NewParentId:string);<i>// Re-parent the given XIDE component&nbsp;</i></li><li>Procedure doEvent(EventType,NodeId,myValue:string);<i> //Execute the event code for the given XIDE event type. To modify the response to an exiting event add an "EventTrapper" component to the system this will see the full event stream&nbsp; allowing you to filter this for the event of interest and code the appropriate additional action.&nbsp; Available information on each event consists of the following system defined variables. "e.EventType, e.NodeId, e.eventvalue : string;" to then continue to run the default event code, set "e.ContinueAfterTrappers = true;" at the end of the event handler&nbsp;</i></li><li>Procedure showXForm(XFormID:String; modal:Boolean);</li><li>Procedure closeXForm(XFormID:String);</li><li>Procedure showBusy;</li><li>Procedure hideBusy;</li><li>Function&nbsp; getGpuPramNumValue(GPUName,pName:String):number;&nbsp;&nbsp;</li><li>Function&nbsp; getGpuConstIntValue(GPUName,pName:String):integer;&nbsp;&nbsp;</li><li>Function&nbsp; getGpuParamImgValue(GPUName,pName:String):TImgArray;&nbsp;&nbsp;</li><li>Procedure setGpuParamNumValue(GPUName,pName:String;pValue:number);</li><li>Procedure setGpuConstIntValue(GPUName,pName:String;pValue:integer);</li><li>Procedure setGpuParamImgValue(GPUName,pName:String;pValue:TImgArray);&nbsp;</li></ul><p><b>App Development and Deployment</b></p><p>During the development phase of a project XIDE&nbsp;will usually be loaded in interactive app design mode where you can edit the user interface design and the code behind it. Here by default, the IDE re-loads the project you were last working on.&nbsp;</p><p>New projects can be started by clearing the current system or loading a previously saved system from the clipboard. This behaves the same in native host environments (Windows or Linux) as it does in Chrome or Android. At the end of this phase, you will sometimes want to deploy the developed app to end users without allowing access to the IDE. In this case, select the "System / Deploy" option from the main menu and this will generate a self contained HTML page implementing your application and the run time environment needed to execute it, but with the interactive IDE features disabled. You can now load this to a server of your choice, or email directly to your end user so they can run it from their file system.&nbsp;</p><p>Alternatively, if you wish to give them access to inspect and perhaps contribute to, or modify, the app, then distribute the blank XIDE app for their preferred platform (Chrome / Linux / Windows / Android) and use the "System / Save" option to generate a app definition file that they can load into it using the "System / Load" option on the main menu.&nbsp;</p><p><b>Debugging</b></p><p>When testing Pascal code you have written using XIDE, the PAS2JS compiler error messages will flag any source code syntax problems. If you click on one of these error messages this will position the cursor at the relevant character position in the line of code in the XIDE&nbsp;code editor. Run time errors will sometimes be trapped by error handlers built in to XIDE&nbsp;and generate a helpful error message. If this is not sufficient to uniquely identify the cause of the problem then "ctrl shift J" in Chrome will bring up the built in developer console which will hopefully provide the additional information you need to track down the problem.</p><h3>Implementation, Extensibility and Licensing<br></h3><p>XIDE is implemented using the Pas2JS dialect of the Object Pascal programming language. This is because it is efficient, easy to learn, and is available on a wide range of processor architectures.&nbsp;</p><p>Sometimes, as projects go through their life cycle, new more specialist requirements emerge. At this point the XIDE framework can be extended using project or platform specific custom components developed in Lazarus. Alternatively the HTML and JavaScript code generated by XIDE can be imported into a general-purpose web design tool stack to enable full enterprise level development.&nbsp;</p><p>XIDE is an open source project distributed using the same licence as Lazarus (GPL)</p><h3>Development Roadmap</h3><p>As an open source project, the future development of XIDE depends on how many collaborators choose to contribute to the project, and which aspects are most important to them.&nbsp;</p><p>The initial project has focused on functionality rather than style or speed, and on the ability to operate as a fully self contained IDE with the minimum of dependencies.&nbsp;</p><p>As the project matures, it is hoped that new collaborators may add web connectivity, database access, comprehensive style support, support for other operating systems (eg IOS) or browsers other than Chrome.&nbsp;</p><h3>Compatibility</h3><p>In desktop mode, XIDE is designed to run on platforms supported by Lazarus and the Chromium Embedded Framework (i.e. most desktop platforms). If the latter is not available then XIDE can still run but will then not support SVG or other embedded browser features.&nbsp;</p><p>In browser mode XIDE should run on any up to date HTML5 enabled browser. However as it is targeting closed user groups (where the browser can be specified)&nbsp; it is only tested on recent versions of Chrome.&nbsp;</p><p>Alternatively, Electron or Cordova and Crosswalk can be used to provide a hybrid implementation of XIDE. This gives full Web connectivity and CSS on a wide range of platforms but with a trade off in terms of size,speed and security.</p><p><br></p><p></p>';



(*
function TXIDEHelpForm.BaseText:String;
var
  txt:TstringList;
begin
  txt:=TStringList.Create;

  txt.Add('Overview ');
  txt.Add('(Helping people write simple apps that work "everywhere")');

  txt.Add('Purpose');
  txt.Add('XIDE is a combined Development and Run Time Environment designed to work in exactly the same way in the Desktop, Browser or Mobile modes with as close to zero installation or learning curve as possible.');

  txt.Add('The target applications are small in house, client side, embedded or exploratory apps where the focus is on specialist functionality and rapid development or collaborative working with cosmetic aspects of the design such as style and speed being a secondary consideration. It is not intended as a tool to develop web pages that are open to the general public although it can be used for prototyping these.');

  txt.Add('Functionality');
  txt.Add('In order to ensure that any project developed with core XIDE will run unmodified in all other environments, it only supports that subset of functionality that exists on all platforms. This is typically that found in the browser as this is the most restrictive environment.  However it is also designed to be easily extensible in order to support user specific project software or hardware requirements.');

  txt.Add('Implementation, Extensibility and Licensing');
  txt.Add('XIDE is implemented using the Pas2JS dialect of the Object Pascal programming language. This is because it is efficient, easy to learn, and is available on  a wide range of processor architectures.');

  txt.Add('Sometimes, as projects go through their life cycle, new more specialist requirements emerge.  At this point an XIDE project can be extended using project or platform specific custom components developed in Lazarus. Alternatively the HTML and JavaScript code generated by XIDE can be imported into a general-purpose web design tool stack to enable full enterprise level development.');

  txt.Add('XIDE is an open source project distributed using the same licence as Lazarus (GPL)');

  txt.Add('Compatibility');
  txt.Add('In desktop or native mode, XIDE is designed to run on platforms supported by Lazarus and the Chromium Embedded framework (i.e. most desktop platforms). If the latter is not available then XIDE can still run but will then not support SVG or other embedded browser features.');

  txt.Add('In browser mode XIDE should run on any up to date HTML5 enabled browser. However it is targeting closed user groups (where the browser can be specified) therefor it is only tested on recent versions of Chrome.');

  txt.Add('In mobile mode, Cordova and Crosswalk allow XIDE to run on Android (4.1 +)');

  txt.Add('Designing a User Interface');

  txt.Add('Resource and Instance trees');
  txt.Add('XIDE uses a very simple paradigm. Essentially, it consists of three elements.');
  txt.Add('1) A resources tree, showing the availablewidgets (visual and non visual)');
  txt.Add('2) A system design tree and object property inspector/editor ');
  txt.Add('3) A layout panel showing a WYSIWYG version of the current page design.');

  txt.Add('The UI is built by dragging nodes from the resource tree to the system design tree. Each node has object properties defined by a name/value pairs that can be edited using the object inspector or referenced and or updated by run time code. Events are also available on each widget so that code can be attached to them using the built in code editor and compiler.  Each property can be bound to a selected data source at design time and code added to validate its status at run time. (Non visual components are dragged to the root node of the instance tree.)');

  txt.Add('Available widgets ');
  txt.Add('The widgets listed in the resource tree include both UI and non visual components. The intention is that each widget is self documenting and that the set can be extended using third party contributions');

  txt.Add('Responsive Design');
  txt.Add('Web development has encouraged new and more flexible approaches to UI design. Unfortunately it has also led to an explosion of choice in this area. In practice this fragmentation creates new costs as well as benefits for our target user base. To counter this trend, XIDE only supports a simple responsive design layout paradigm.');

  txt.Add('In practice this consists of  a  Main page, Tab controls and Popups to define the constituent pages in a UI design. Horizontal and Vertical layout boxes (together with associated alignment properties) are then nested within these pages to control the final layout of components on the page.');


  txt.Add('Writing application code ');
  txt.Add('Xide uses an event driven model where event handlers written in Pascal can be attached to pre defined events triggered by objects in the user interface. ');

  txt.Add('These procedures can be inspected and/or edited by using the object inspector to navigate to the required UI object then pressing the ellipsis button to the right of the required event in its events tab. This creates an entry for that event handler under the Event Handlers node in the code design tree. So once a handler has been added it can then also be navigated to by selecting it in the code designer and pressing the edit button.');

  txt.Add('Pascal Syntax');
  txt.Add('The Pascal syntax recognised by Xide is that used by the Pas2JS variant of Free Pascal. (http://wiki.freepascal.org/pas2js) A detail description of the supported syntax can be found here. (http://wiki.freepascal.org/pas2js#RTL)');

  txt.Add('Unit Structure ');
  txt.Add('Shared code can be written by adding units and procedures directly to the code design tree. This allows some automation of routine tasks, however to allow maximum flexibility, it is also possible to add standard Pascal units developed elsewhere as Raw Units. These must have the Interface unit added to their uses clause in order to be able to access the Xide API. In addition, they can access any of the standard set of PAS2JS run time library units. (http://wiki.freepascal.org/pas2js#RTL) Any other required units must be imported into Xide as additional Raw Units before they can be referenced.');

  txt.Add('Accessing user interface objects at run time ');
  txt.Add('Xide is designed to be a cross platform rapid application development system. In order to do this it uses a text based system description tree  (The System Design or  instance tree) to reflect the state of a users program at all time. This is similar to the function of the Document Object Model (DOM) in standard web applications.');

  txt.Add('Types of API Calls');
  txt.Add('In the IDE the instance tree describing a users project can be inspected manually using the Object Inspector.  This allows the user to select any node on the tree and inspect and/or modify its properties or event handlers as required.');

  txt.Add('The Xide API allows the same actions to be available programmatically. This ability to generate events using code is particularly useful in automated testing, asynchronous call back functions, or multithreading applications.');

  txt.Add('The functions available fall into six types viz:- ');
  txt.Add('1) Dialog boxes ');
  txt.Add('2) Get and/or set a property value of a UI object');
  txt.Add('3) Save and load user selected data to the clipboard');
  txt.Add('4) Create, copy or move a component to a new parent.');
  txt.Add('5) Add to, or replace, a UI object event handler and/or trigger such an event artificially');
  txt.Add('6) Show or hide a popup form.');

  txt.Add('The detail syntax for these function calls is appended below. Note that all values are either strings or string arrays. ');

  txt.Add('Asynchronous Calls, Multi Threading and Initialization functions ');
  txt.Add('Many web calls issue requests that need to wait for a response from a web service, database or other remote service provider. Similarly, when starting another thread in parallel, the main thread will often need to wait for such child threads to return the results of their work before it can proceed.');

  txt.Add('XIDE allows main event handlers to specify a initalisation function.  This is a block of code which issues all such requests prior to running the main event code when they have all finished executing.  See below for the detail syntax of the available calls. Note however that all such asynchronous calls first parameter is ec the event context (automatically declared and populated by Xide, behind the scenes, for every Xide event) from which they have been issued so they know where to return without requiring the user to enter complex boilerplate code.');

  txt.Add('List of Xide API procedure and function calls');
  txt.Add('procedure showmessage(msg:String);');
  txt.Add('Function confirm(TextMessage:string):boolean;');
  txt.Add('Function prompt(TextMessage,promptString:string):string;');

  txt.Add('procedure setPropertyValue(nodeName:String;propName:String;newValue:String); ');
  txt.Add('procedure setPropertyValueIndexed(nodeName:String;propName:String;newValue:TStringArray; x,y:integer); ');
  txt.Add('function getPropertyValue(nodeName:String;propName:String):string; ');
//  txt.Add('function getPropertyValueIndexed(nodeName:String;propName:String; x,y,w,h:integer):TstringArray; ');

  txt.Add('procedure ShowXForm(XFormID:String; modal:Boolean);');
  txt.Add('procedure CloseXForm(XFormID:String);');

  result:=txt.Text;

  txt.Free;
end;
*)

{ TXIDEHelpForm }

{$ifndef JScript}
procedure TXIDEHelpForm.FormCreate(Sender: TObject);
begin
  myNode:=DoXFormCreated(self);
  HelpFormRoot:=FindDataNodeById(myNode,'HelpFormVBox1','',true);

  HelpHTMLText.SourceText:=BaseHTML;

//  self.HelpHTMLEditor.SuspendRefresh:=true;
//  self.HelpHTMLEditor.HeaderHTML:='<h2 style=" text-align: center;">XIDE -- (A Free-Pascal Run Time Environment for Chrome/Linux/Windows/Android)</h2>';
//  self.HelpHTMLEditor.FooterHTML:='<h5 style=" text-align: center;">Powered by PAS2JS courtesy of Michael Van Canneyt and Mattias Gaertner see http://wiki.freepascal.org/pas2js for details. </h5>';
//  self.HelpHTMLEditor.SuspendRefresh:=false;


end;

procedure TXIDEHelpForm.FormActivate(Sender: TObject);
begin
end;

procedure TXIDEHelpForm.FormResize(Sender: TObject);
begin
  DoFormResize(self, HelpFormVBox1);
end;

procedure TXIDEHelpForm.FormShow(Sender: TObject);
begin
  {$ifdef Chromium}
  // cef issue.  Browser is reset to nil once the form is displayed (so Editor comes up blank), so reinitialize here if reqd.
//  HelpHTMLEditor.myStartupTimer.Enabled := True;
//  HelpHTMLEditor.RedisplayFrame('');
  {$endif}

end;

procedure TXIDEHelpForm.LoadNewText(Data: PtrInt);
var
  ss: TStringStream;
  NewHTML: TIpHtml;
 // called from main thread after all other messages have been processed to allow thread safe TMemo access
  ReceivedQueueRec: TQueueRec;
begin
  ReceivedQueueRec := PQueueRec(Data)^;
  ss := TStringStream.Create(ReceivedQueueRec.QEventValue);
  try
    NewHTML := TIpHtml.Create; // Will be freed automatically by IpHtmlPanel1
    TIpHtmlPanel(XIDEHelpForm.HelpHTMLText.myControl).SetHtml(NewHTML);
    NewHTML.LoadFromStream(ss);
  finally
    ss.Free;
  end;
end;

(*
//!!!! async proc here to fetch new value
procedure TXIDEHelpForm.HelpHTMLEditorHandleChange(e: TEventStatus;
  nodeID: AnsiString; myValue: AnsiString);
var
  newText:String;
  ss: TStringStream;
  NewHTML: TIpHtml;
  QueueRecToSend: PQueueRec;
begin
  // !! got here via an event raised inside the HTMLEditor, so there's some cef-internal threading going on, so
  // we can't directly update another component from here (likely to fall over) and also can't throw a timer,
  // so do whatever is next by using an async function (which will run in the main thread and not cause problems).
  // HelpHTMLText.SourceText:=HelpHTMLEditor.SourceText;

  newText:=HelpHTMLEditor.SourceText;
  newText:=HelpHTMLText.CreateTextURL(newText).Text;
  HelpHTMLText.myNode.SetAttributeValue('SourceText',newText);

  New(QueueRecToSend);
  QueueRecToSend^.QEventValue:= newText;
  Application.QueueAsyncCall(@self.LoadNewText, PtrInt(QueueRecToSend)); // put msg into queue that will be processed from the main thread after all other messages
end;
*)

{$endif}

procedure TXIDEHelpForm.InitialiseonShow;
var
  txt:String;
begin
  self.Top:=100;
  self.Left:=150;
  HelpHTMLText.SourceText:=HelpHTMLText.SourceText;

end;

end.

