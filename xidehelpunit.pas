(*
    Copyright (c) 2020  Steve Wright

    This unit is part of the XIDE project.

    This project is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

 **********************************************************************
 *)
unit XIDEHelpUnit;
{$ifndef JScript}
{$mode objfpc}{$H+}
{$endif}

interface

uses
  Classes, SysUtils, StringUtils, NodeUtils, XForm,
  {$ifndef JScript}
  Forms, Controls, Dialogs,LazsUtils, Events, {framView,}
  {$else}
  HTMLUtils,
  {$endif}
  WrapperPanel, XVBox, XHBox, XMemo, XButton,
  XLabel, XEditBox, XHTMLText, XScrollBox, XHTMLEditor;

type

  { TXIDEHelpForm }

  TXIDEHelpForm = class(TXForm)
    HelpFormVBox1: TXVBox;
    HelpHTMLText: TXHTMLText;
    {$ifndef JScript}
    procedure FormActivate(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormResize(Sender: TObject);
    procedure FormShow(Sender: TObject);
//    procedure LoadNewText(Data: PtrInt);
    {$endif}
  private

  public
     procedure InitialiseonShow;
  end;


var
  XIDEHelpForm: TXIDEHelpForm;
  HelpFormRoot:TDataNode;

implementation

{$R *.lfm}

const BaseHtml =
//'<h1 style="text-align: center;"><u>XIDE Overview</u></h1><h2 style="text-align: center;">&nbsp;(A simple "Browser-First" IDE for Pascal and Python)</h2><h3>Purpose</h3><p>XIDE is a combined Client Side Run Time Library and RAD IDE intended to allow Pascal and/or Python development in the browser with the minimum of installation overhead or learning curve while also being as platform independent as possible. It is targeted at Prototyping, Small Group Collaboration and Agile Line of Business projects on any platform that is supported by Chrome or Electron, or Lazarus (and the Chrome Embedded Framework).&nbsp; It is not intended for the development of general-purpose public facing web sites.</p><h3>Installation</h3><p>In the browser, XIDE for Chrome is a single page static HTML page with no dependencies. so installation is just a matter of loading that initial web page. All subsequent computation and data storage is done client side. This single page web app&nbsp; combines the currently selected user project, as well as the RTL and IDE Code so any user project can be deployed with the IDE disabled (for end users) or enabled (for collaborators) as required.</p><p>Python in XIDE is based on the Mozilla Pyodide project which brings a full data science stack to the browser, such as NumPy, Pandas and Matplotlib.&nbsp;</p><p>If using a snapshot of XIDE on the desktop (i.e. XIDE.exe), you need to&nbsp; install local copies of Free Pascal and Python following the relevant instructions on their web sites. Then using the XIDE.exe main menu "Settings" option set the path to the home directories for the fpc compiler. Alternatively to rebuild XIDE from source, see&nbsp;&nbsp;<a href="https://github.com/Steve--W/XIDE">https://github.com/Steve--W/XIDE.</a>&nbsp;</p><h3>Functionality</h3><p>XIDE is designed to bring the power of Free Pascal (Pas2JS) and the convenience of&nbsp; Rapid Application Development (RAD) to the browser. It&nbsp; is a "Browser First" approach which also delivers cross platform capability by replicating browser functionality on the desktop in native code. This allows the user to exploit the greater efficiency of compiled native code compared to interpreted browser environments as required. It also allows a single code base to support multiple different target environments for different user circumstances or different stages in a project.&nbsp;</p><p>The Python option in XIDE adds broader "Data Science" capabilities to the environment and&nbsp; allows the more interactive exploratory approach of Python to be exploited as required. See&nbsp;&nbsp;<a href="https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/">https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/</a></p><h3>Unified User Interface<br></h3><p>The browser supports a number of different standards as part of its user interface. These include HTML, CSS, SVG&nbsp; to cover page layout, style editing, and vector graphics respectively. Normally these all require their own conventions to be used when accessed directly from the browser and/or JavaScript. XIDE unifies the user''s access to these different browser capabilities using a standardised Object Inspector / Drag and Drop approach for them all. For HTML and SVG this should appear seamless to the user with all the SVG containers and components accessed in an identical manner to HTML so requiring no further explanation than provided below for basic screen layout and editing.&nbsp;</p><h3>CSS Functionality</h3><p>CSS functionality is provided by supporting a style design tree in addition to the Code and UI design trees described below. As with the UI design tree, Style resources (new design rules, targets, properties and rule types ) are dragged from a resources tree and dropped on the relevant node of the style tree. The style tree also supports logical grouping of targets using "AND" and "OR" nodes.&nbsp; This speeds up and simplifies the CSS syntax generation considerably compared to direct text entry.</p><p></p><h3>Designing a User Interface<br></h3><p><b>Resource and Instance trees</b></p><p>XIDE uses a very simple paradigm. Essentially, it consists of three elements.</p><p></p><ol><li>&nbsp;A resources tree, showing the available widgets (visual and non visual)</li><li>&nbsp;A system design tree and object property inspector/editor</li><li>&nbsp;A layout panel showing a WYSIWYG version of the current page design.</li></ol><p></p> <p>The UI is built by pasting nodes from the resource tree to the system design tree. Each node has object properties defined by a name/value pairs that can be edited using the object inspector or referenced and or updated by run time code. Events are also available on each widget so that Pascal code can be attached to them using the built in code editor and compiler. Python scripts can also be called from these event handlers.</p><p><b>Available Widgets</b></p><p>The widgets listed in the resource tree include both UI and non visual components (the latter can be added to the root node of the UI design tree).&nbsp;</p><p><b>Responsive Design</b></p><p>XIDE supports a simple Responsive Design layout paradigm which consists of a Main page, Tab controls and Popups to define the constituent pages in a UI design. Horizontal and Vertical layout boxes (together with associated alignment properties) are then nested within these pages to control the final layout of components on the page.</p><p><b>Writing Application Code</b></p><p>XIDE uses an event driven model where event handlers can be attached to pre-defined events triggered by objects in the user interface. These procedures can be inspected and/or edited by using the object inspector to navigate to the required UI object then pressing the ellipsis button to the right of the required event in its events tab. This creates an entry for that event handler under the "Event Handlers" node in the code design tree. So once a handler has been added it can then also be navigated to by selecting it in the code designer and pressing the edit button.&nbsp;</p><p><b>Pascal Syntax</b></p><p>The Pascal syntax recognised by XIDE&nbsp;is that used by the Pas2JS variant of Free Pascal. (<a href="http://wiki.freepascal.org/pas2js">http://wiki.freepascal.org/pas2js</a>). A detailed description of the supported syntax can be found here. (<a href="http://wiki.freepascal.org/pas2js#RTL">http://wiki.freepascal.org/pas2js#RTL</a>)</p><p><b>Unit Structure</b></p><p>In addition to the event handler nodes, shared code can be written by adding units directly to the code design tree as "Pascal Units" or "Python Scripts".&nbsp;&nbsp;</p><p>Functions and procedures&nbsp; in the code nodes can be amended or deleted by selecting the node on the code design tree and pressing the "Edit" button which will bring up the code editor screen as previously described for&nbsp; the event handler code. After a Pascal unit has been compiled for the first time in a session, all the procedures and functions declared in it are displayed as its child nodes in the code design tree. Selecting one of these nodes and pressing the edit button below will navigate directly to that function. Alternatively, selecting a node and pressing "Code Search" will list all references to that function or procedure allowing you to navigate directly to the most relevant reference.</p><h3><b>Python&nbsp;</b></h3><p>The Python syntax used is version 3.8.&nbsp;</p><p>Python does not have a unit structure like Pascal, however blocks of Python code can be added to the Code Designer tree in the same way as Pascal units. The difference is that these will be run&nbsp; when entering run mode. They are executed in the order they occur on the Code Designer tree and can contain initialisation, declarations and / or&nbsp; any other valid executable Python Code.&nbsp;</p><p>To execute Python code elsewhere, such as in an event handler, then simply invoke the "RunPython(<i>......</i>)" procedure with the relevant python function call (or code) as a string parameter,</p><p>A console output box is supplied so that Python errors and print statements can be viewed. On the desktop, the copy of Python being used is the version installed on the host machine, see the documentation for that system to review valid syntax, permissions etc. In the browser, the version of Python used is that supported by mozilla (see&nbsp;<a href="https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/">https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/</a>)</p><p><b>Accessing user interface objects at run time</b></p><p>XIDE is designed to be a cross platform rapid application development system. In order to do this it uses a text based system description tree (The System Design or Instance Tree) to reflect the state of a users program at all times. This is similar to the function of the Document Object Model (DOM) in standard web applications. All object properties for nodes on this tree can be accessed and updated using the supplied get and set calls (see below).</p> <p><b>Types of API Calls</b></p><p>In XIDE design mode the instance tree describing a users project can be inspected manually using the Object Inspector. This allows the user to select any node on the tree and inspect and/or modify its properties or event handlers as required. The XIDE&nbsp;API allows the same actions to be available programmatically. The functions available fall into the following types (and work in an identical manner in both Pascal and Python) viz:-</p><p></p><ul><li>&nbsp;Dialog boxes</li><li>&nbsp;Get and/or set a property value of a UI object</li><li>&nbsp;Save and load user selected data to the clipboard or local storage</li><li>&nbsp;Copy or delete a UI component or move it to a new parent.</li><li>&nbsp;Show or hide a popup form.</li><li>&nbsp;Show or hide a busy indicator.</li><li>&nbsp;get and set GPU parameters&nbsp;</li></ul><p></p><p>The detailed syntax for these function calls is appended below. Note that unless explicitly stated, all values are strings.</p><p><b>Asynchronous Calls, Multi Threading and Initialization functions</b></p><p>Many web calls issue requests that need to wait for a response from a web service, database or other remote service provider. Similarly, when starting another thread in parallel, the main thread will often need to wait for such child threads to return the results of their work before it can proceed. XIDE&nbsp;allows main event handlers to specify a "initalisation"function. This is a block of code which issues all such requests prior to running the main event code when they have all finished executing. See below for the detail syntax of the available calls.</p><p>Note however that all such asynchronous calls first parameter is "e" the event context (automatically declared and populated by XIDE, behind the scenes, for every XIDE&nbsp;event) from which they have been issued so they know where to return without requiring the user to enter complex boilerplate code.</p><h3><b><u>List of&nbsp;XIDE&nbsp;specific API procedure and function calls</u></b></h3> <p></p><h3><u>General Functions</u></h3><ul><li>procedure SetPropertyValue(nodeName,propName,newValue:String);&nbsp;&nbsp;&nbsp; &nbsp;<font color="#0000ff">set a component property (string value)&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;GetPropertyValue(nodeName,propName:String);&nbsp;<font color="#0000ff">&nbsp; &nbsp;returns a component property value (as string)&nbsp;</font></li><li>procedure SetPropertyValueIndexed(nodeName,propName:String;newValue:TStringArray; x,y:integer);&nbsp;&nbsp; &nbsp;<font color="#0000ff">set a portion of a component array property</font>&nbsp;&nbsp;</li><li>procedure CopyToClip(str:String);&nbsp;&nbsp;<font color="#0000ff">&nbsp;copies the given string to the clipboard&nbsp;</font></li><li>function&nbsp; &nbsp;CopyFromClip(e:TEventStatus):String;&nbsp;&nbsp;&nbsp;<font color="#0000ff">CopyFromClip is an async function (required for browser use), so it must be coded in the&nbsp;&nbsp;''Init'' section of an event handler. The result here is a blank string.&nbsp;&nbsp;&nbsp;The clipboard string is held in e.ReturnString, which can be picked up in the&nbsp;&nbsp;&nbsp; &nbsp;''Main'' section of the event handler.</font></li><li>procedure ShowXForm(XFormID:String; modal:Boolean);&nbsp;&nbsp;<font color="#0000ff">&nbsp;opens a TXForm. [note:''modal=false'' currently only effective on desktop]&nbsp;</font></li><li>procedure CloseXForm(XFormID:String);&nbsp;&nbsp;<font color="#0000ff">&nbsp;closes a TXForm.&nbsp;&nbsp;</font></li><li>procedure DoEvent(EventType,NodeId,myValue:String);&nbsp;<font color="#0000ff"> executes the event handler defined for the given event type and component.&nbsp;</font></li><li>procedure MoveComponent(nodeId:string;NewParentId:string);&nbsp;&nbsp;<font color="#0000ff">re-parents the given UI component&nbsp;</font></li><li>procedure CopyComponent(nodeId,NewParentId,NewName:string);&nbsp;<font color="#0000ff">copies the given UI component and places the clone under the given parent&nbsp;</font></li><li>function&nbsp; &nbsp;DeleteComponent(nodeId:string;ShowNotFoundMsg:Boolean=true):Boolean;&nbsp;&nbsp; <font color="#0000ff">&nbsp;deletes the given UI component. Returns false if not done.&nbsp;</font></li><li>function&nbsp; &nbsp;UserSystemAsString():String;&nbsp; <font color="#0000ff">Returns the string representation of the current user system (can be imported to XIDE via System&gt;Load)&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;LoadUserSystemString(SystemString:String);&nbsp;&nbsp;<font color="#0000ff">Imports a new user system to the XIDE framework (can only be done in ''Design'' mode)&nbsp;</font></li><li>procedure ShowBusy(e:TEventStatus);&nbsp;&nbsp;<font color="#0000ff">Shows the busy cursor&nbsp;ShowBusy is an async function (required for browser use), so it must be coded in the&nbsp; ''Init'' section of an event handler.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></li><li>procedure HideBusy;&nbsp; &nbsp;<font color="#0000ff">Hides the busy cursor&nbsp;</font>&nbsp;</li><li>procedure ProcessMessages;&nbsp; <font color="#0000ff">&nbsp;Functional in Desktop execution only.&nbsp; Executes a pascal Application.ProcessMessages statement.&nbsp;&nbsp;</font></li><li>procedure DebugStart;&nbsp; &nbsp;<font color="#0000ff">Functional in Browser execution only.&nbsp; Executes a Javascript ''debugger;'' statement - starts the native browser debug facility.&nbsp;&nbsp;</font></li><li>procedure RunPython(str:String);&nbsp;<font color="#0000ff">&nbsp;Executes the given Python script&nbsp;</font></li><li>procedure PyodideLoadPackage(nm:String);&nbsp;<font color="#0000ff">&nbsp;Functional in Browser execution only.&nbsp; Loads the requested Pyodide/python package, so that it will be available for import.&nbsp;</font></li><li>function PyodidePackageLoaded(nm:String):Boolean;&nbsp;<font color="#0000ff">&nbsp;Functional in Browser execution only.&nbsp; Returns true if the named package has been loaded into the Pyodide environment.&nbsp;&nbsp;</font>&nbsp; &nbsp;</li></ul></div><div contenteditable="true"><ul></ul><h3><u>Messages and Dialogs</u></h3><ul><li>procedure ShowMessage(msg:String);&nbsp; <font color="#0000ff">&nbsp;displays a popup alert&nbsp;</font></li><li>function&nbsp; &nbsp;Confirm(TextMessage:string):boolean;&nbsp;&nbsp;<font color="#0000ff">displays a confirmation alert; returns true/false&nbsp;</font></li><li>function&nbsp; &nbsp;Prompt(TextMessage,promptString:string):string;&nbsp;&nbsp;&nbsp;<font color="#0000ff">displays an input box; returns user-entered string&nbsp;</font></li><li>procedure ConsoleLog(txt:String);&nbsp; <font color="#0000ff">Writes a debug message to the console log&nbsp;&nbsp;</font></li></ul><ul></ul><h3><u>TXTable Functions</u></h3><ul><li>procedure&nbsp; LoadTableFromExcelCopy(TableName,CopiedString:String);&nbsp;&nbsp;<font color="#0000ff">Populate the given TXTable component with a string in Excel format (eg. as copied from a spreadsheet)&nbsp;&nbsp;</font></li><li>procedure&nbsp; LoadTableFromNumArray(TableName,NumArray:T2DNumArray);&nbsp;&nbsp;<font color="#0000ff">Populate the given TXTable component from a 2D numeric array&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;GetTableDataArray(TableName:String;SkipHeader:Boolean):T2DStringArray;&nbsp;&nbsp;<font color="#0000ff">&nbsp;Fetch the cells from the given TXTable component as a 2D string array&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;Array2DToString(arr:T2DNumArray):String;&nbsp; <font color="#0000ff">&nbsp;Convert numeric 2D array to string form eg. [[...],...,[...]]&nbsp;&nbsp;</font></li></ul><ul></ul><h3><u>TXGPUCanvas Functions</u></h3><ul><li>function&nbsp; &nbsp;GetGPUParamNumValue(GPUName,pName:String):TNumArray;&nbsp;&nbsp;<font color="#0000ff">For the given TXGPUCanvas component, returns the value of the named numeric parameter as an array&nbsp;</font></li><li>function&nbsp; &nbsp;GetGPUConstIntValue(GPUName,pName:String):integer;&nbsp; <font color="#0000ff">&nbsp;For the given TXGPUCanvas component, returns the value of the named integer parameter&nbsp;</font></li><li>procedure SetGPUParamNumValue(GPUName,pName:String;pValue:TNumArray);&nbsp;&nbsp;<font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named numeric parameter as a 1-D array&nbsp;</font></li><li>procedure SetGPUParam2DNumValue(GPUName,pName:String;pValue:T2DNumArray);&nbsp; &nbsp;<font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named numeric parameter as a 2-D array&nbsp;</font></li><li>procedure SetGPUConstIntValue(GPUName,pName:String;pValue:integer);&nbsp; &nbsp; <font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named integer parameter&nbsp;</font></li><li>function&nbsp; &nbsp;GetGPUPixelArray(GPUName:String):T3DNumArray;&nbsp;&nbsp;<font color="#0000ff">&nbsp;Fetch the current Pixel array for the given TXGPUCanvas component&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;GetGPUPixelArrayAsString(GPUName:String):String;&nbsp;&nbsp;<font color="#0000ff">Fetch the current Pixel array in string format for the given TXGPUCanvas component&nbsp;</font>&nbsp;</li><li>function&nbsp; &nbsp;GetGPUStageArray(GPUName:String):T3DNumArray;&nbsp;&nbsp;&nbsp;<font color="#0000ff"> Fetch the stage array (resulting from the non-graphical kernel stack) for the given </font>TXGPUCanvas component&nbsp;&nbsp;</li><li>function&nbsp; &nbsp;GetGPUStageArrayAsString(GPUName:String):String;&nbsp; &nbsp;<font color="#0000ff">Fetch the stage array in string format for the given TXGPUCanvas component&nbsp;&nbsp;</font></li></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><h3>&nbsp;<u>Python Only</u></h3><ul><li>function&nbsp; ShowPythonPlot(ImgName,fig)<font color="#0000ff">&nbsp; In the given TXImage component, displays the contents of fig (a matplotlib figure)&nbsp;</font></li></ul><p><b>Project Development and Deployment</b></p><p>During the development phase of a project XIDE&nbsp;will usually be loaded in design mode where you can edit the user interface design and the code behind it. On startup on the desktop, the IDE re-loads the project you were last working on. On the browser, it can be set to revert to the original state every time the app is started or to reload from the previous session.</p><p>Existing projects can be loaded from a previously saved system in local storage, or from the clipboard. Clearing the current system will start a new project. At the end of the design phase, you will sometimes want to deploy the developed HTML app to end users without allowing access to the IDE. In this case, select the "System / Deploy" option from the main menu and this will generate a self contained HTML page implementing your application and the run time environment needed to execute it, but with the interactive IDE features disabled. You can now load this to a server of your choice, or email directly to your end user so they can run it from their file system.&nbsp;</p><p>Alternatively, if you wish to give them access to inspect and perhaps contribute to, or modify, the app, then distribute the blank XIDE app for their preferred platform&nbsp; and use the "System / Save" option to generate a project definition file that they can load into it using the "System / Load" option on the main menu.&nbsp;</p><p><b>Debugging</b></p><p>When testing Pascal code you have written using XIDE, the PAS2JS compiler error messages will flag any source code syntax problems. If you click on one of these error messages this will position the cursor at the relevant character position in the line of code in the XIDE&nbsp;code editor. Run time errors will sometimes be trapped by error handlers built in to XIDE&nbsp;and generate a helpful error message. If this is not sufficient to uniquely identify the cause of the problem then "ctrl shift J" in Chrome will bring up the built in developer console which will hopefully provide the additional information you need to track down the problem. Alternatively, a break point can be set in the code by inserting a "DebugStart;" instruction that will start the native browser debug facility at that point.</p><h3>Implementation, Extensibility and Licensing<br></h3><p>XIDE is implemented using the Pas2JS dialect of the Object Pascal programming language. This is because it is efficient, easy to learn, and is available on a wide range of processor architectures.&nbsp;</p><p>Sometimes, as projects go through their life cycle, new more specialist requirements emerge. At this point the XIDE framework can be extended using project or platform specific custom components developed in Lazarus.&nbsp;</p><p>XIDE is an open source project distributed using the same licence as Lazarus (GPL) Source code is available from GitHub&nbsp; see <a href="https://github.com/Steve--W/XIDE">here</a> for the IDE and&nbsp;<a href="https://github.com/Steve--W/XComponents">here</a> for the components used to build it. (see <font color="#0000ff">https://github.com/Steve--W/XIDE</font> and<font color="#0000ff"> https://github.com/Steve--W/XComponents</font> respectively)</p><h3>Development Roadmap</h3><p>I have developed XIDE&nbsp; to support my ongoing academic research projects. I have made the project open source in case it should prove useful to anyone else. In particular, I hope its browser first approach, low installation overhead and easy learning curve will help to introduce the&nbsp; joys of Free Pascal and Lazarus to a wider audience.<br></p><p>Those aspects of XIDE and XComponents that I use regularly are "tried and tested". Some aspects that are used less often may have more bugs, and there are many aspects where it would be great to add new or improved features but where I do not have the bandwidth to address at the moment. If&nbsp; anyone wants to help out with any improvement to XIDE then their contribution will be most welcome.</p><p>(Some topics that spring to mind, from a long list of potential improvements, are:-&nbsp; Broadening XIDE browser support beyond the Chrome compatible set, XIDE integration with Lazarus, improving the wrapper for GPUJS or adding a drag and drop utility for constructing MatPlotLib data visualisations to make these Python libraries easily accessible to the Pascal community. )</p><h3>Compatibility</h3><p>In desktop mode, XIDE is designed to run on platforms supported by&nbsp; Lazarus, and optionally, the&nbsp; Chromium Embedded Framework and&nbsp; Python (i.e. most desktop platforms). If CEF or Python is not available then XIDE can still run but will then not support their specialist features.&nbsp; Alternatively, Electron or Cordova and Crosswalk can be used to provide a hybrid implementation of XIDE. This gives full Web connectivity and CSS on a wide range of platforms but with a trade off in terms of size, speed and security.</p><p>In browser mode XIDE is targeting closed user groups (where the browser can be specified) so it is only tested on recent versions of Chrome but it may also work on other browsers which use a Chrome engine. (e.g. the latest version of Microsoft Edge)&nbsp;</p><p>Note that the Style Designer is only available on the Browser versions as it depends on CSS functionality.</p><h3>Motivation for including a GPU capability in XIDE</h3><p>XIDE provides a thin wrapper for GPUJS (See https://gpu.rocks/) which generates GPU code from JavaScript. This produces WebGL code as it is widely supported "out of the box"&nbsp; in most browsers and on most processor/GPU combinations. This minimises the&nbsp; installation and configuration needed in order to get GPU code running on a new system. As such it is a good way to start learning about the possibilities (and perhaps more importantly the limitations) of programming for a massively parallel platform.&nbsp;</p><p>One of the weaknesses of this approach is the frustrating inability to optimise code or diagnose bugs in the GPU kernels except by exhaustive trial and error.&nbsp; So for any serious GPU programming it is well worth investing the time in getting to grips with the (admittedly intimidating) learning curve needed to master tools like OpenCL or Cuda and the associated tool stacks. Having said that, for simple "embarrassingly parallel" examples, or where there is a need to build simple GPU code into more general purpose or widely shared apps, the GPUJS approach can be very helpful.</p><h3>The XIDE GPUJS Wrapper</h3><p>The Pascal code for the GPU is accessed as a property of a GPU Canvas component which has been dropped onto the User Interface layout screen and/or as a node on the Code designer tree.&nbsp; The Pascal GPU code editor follows the same edit/compile cycle as for user code in the rest of the system. The differences are that this is code for blocks of threads in parallel. The code describes a single instruction multiple data (SIMD) approach where all the threads run the same code with thread specific code referencing "this.thread.x" , "this.thread.y" and "this.thread.z" to reflect their position in the block of threads. Parameter names are declared using a Paramlist property of the GPU canvas component and their transfer and run time execution is controlled by system calls described below. (N.B. parameters need to be passed as arrays so even scalar parameters passed into the code need to be referenced as follows "myParam[0]" )<br></p><p>The Pascal GPU code can daisy chain kernels. (Set the TXGPUCanvas property NumKernels&gt;0) For each kernel in the chain its return value must be set to "MyValue". The next kernel in the chain can then read all the thread return values from the previous kernel by reading from "MyArray".The initial "MyArray" passed to the first kernel in the chain is set as a property ("InitStageData") of the GPU canvas and can have any x,y,z sizes as chosen by the user. The final&nbsp; &nbsp;kernel is the graphics display kernel where you set the r,g,b values as usual. The calculated data input to the graphics display kernel can also be accessed using either the "GetGPUStageArray" or "GetGPUStageArrayAsString" instructions;</p><p>Maths functions available in the GPU code are as follows:-</p><p></p><ul><li>abs(a) sign(a) trunc(a) ceil(a) max(a,b) min(a,b)</li><li>sin(a) cos(a) arcsin(a) arccos(a) arctan(a,b)</li><li>sqrt(a) power(a,b) ln(a) log10(a) log2(a)&nbsp;</li></ul><h3>Limitations of coding for the GPU&nbsp;</h3><p>When coding in Pascal for the GPU, you should be aware that there are fundamental limitations on the constructs available. In particular:-</p><p></p><ul><li>All parameters passed into the GPU&nbsp; are real arrays (scalar parameters are real arrays of length one)<br></li><li>You can read from but not write to any of these array parameters</li><li>You cannot declare a local array</li><li>Each thread returns a single real value</li><li>You cannot communicate with any other thread (except by synchronising the results in a new kernel)</li><li>You cannot use a Boolean type (use 0 or 1 instead)</li><li>You cannot use "var" parameters in a function call</li><li>All function parameters must be a simple type</li><li>Nested function declarations do not follow normal (Pascal) scope rules</li><li>Loops are unrolled so you MUST SET the "<span style="font-family: Verdana, Arial, sans-serif; font-size: 12px; white-space: nowrap;">MaxIterations"</span>&nbsp;parameter at a high enough value to reflect your algorithm''s requirements</li><li>The number of threads in each kernel are given by the KernelXDims, KernelYDims and Kernel ZDims properties of the GPU Canvas and these MUST BE SET either manually or programatically before activating the GPU.</li><li>The GPU is a Single Instruction Multiple Data machine so branching in a thread does not jump over the code in the path not taken,&nbsp; it idles in order to allow other threads to execute the code in that path if need be.&nbsp;</li><li>Debugging on the GPU is "primitive" the only way to do it when running on the hardware is to write out intermediate results&nbsp; to the thread output value for selected threads which you dedicate to providing diagnostic output.&nbsp;</li></ul><p><br></p><p><br></p><p></p>';
//'<h1 style="text-align: center;"><u>XIDE Overview</u></h1><h2 style="text-align: center;">&nbsp;(A simple "Browser-First" IDE for Pascal and Python)</h2><h2>Purpose</h2><p>XIDE is a combined Client Side Run Time Library and RAD IDE intended to allow Pascal and/or Python development in the browser with the minimum of installation overhead or learning curve while also being as platform independent as possible. It is targeted at Prototyping, Small Group Collaboration and Agile Line of Business projects on any platform that is supported by Chrome or Electron, or Lazarus (and the Chrome Embedded Framework).&nbsp; It is not intended for the development of general-purpose public facing web sites.</p><h2>Installation</h2><p>In the browser, XIDE for Chrome is a single page static HTML page with no dependencies. so installation is just a matter of loading that initial web page. All subsequent computation and data storage is done client side. This single page web app&nbsp; combines the currently selected user project, as well as the RTL and IDE Code so any user project can be deployed with the IDE disabled (for end users) or enabled (for collaborators) as required.</p><p>Python in XIDE is based on the Mozilla Pyodide project which brings a full data science stack to the browser, such as NumPy, Pandas and Matplotlib.&nbsp;</p><p>If using a snapshot of XIDE on the desktop (i.e. XIDE.exe), you need to&nbsp; install local copies of Free Pascal and Python following the relevant instructions on their web sites. Then using the XIDE.exe main menu "Settings" option set the path to the home directories for the fpc compiler. Alternatively to rebuild XIDE from source, see&nbsp;&nbsp;<a href="https://github.com/Steve--W/XIDE">https://github.com/Steve--W/XIDE.</a>&nbsp;</p><h2>Functionality</h2><p>XIDE is designed to bring the power of Free Pascal (Pas2JS) and the convenience of&nbsp; Rapid Application Development (RAD) to the browser. It&nbsp; is a "Browser First" approach which also delivers cross platform capability by replicating browser functionality on the desktop in native code. This allows the user to exploit the greater efficiency of compiled native code compared to interpreted browser environments as required. It also allows a single code base to support multiple different target environments for different user circumstances or different stages in a project.&nbsp;</p><p>The Python option in XIDE adds broader "Data Science" capabilities to the environment and&nbsp; allows the more interactive exploratory approach of Python to be exploited as required. See&nbsp;&nbsp;<a href="https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/">https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/</a></p><h2>Unified User Interface</h2><p>The browser supports a number of different standards as part of its user interface. These include HTML, CSS, SVG&nbsp; to cover page layout, style editing, and vector graphics respectively. Normally these all require their own conventions to be used when accessed directly from the browser and/or JavaScript. XIDE unifies the user''s access to these different browser capabilities using a standardised Object Inspector / Drag and Drop approach for them all. For HTML and SVG this should appear seamless to the user with all the SVG containers and components accessed in an identical manner to HTML so requiring no further explanation than provided below for basic screen layout and editing.&nbsp;</p><h2>CSS Functionality</h2><p>CSS functionality is provided by supporting a style design tree in addition to the Code and UI design trees described below. As with the UI design tree, Style resources (new design rules, targets, properties and rule types ) are dragged from a resources tree and dropped on the relevant node of the style tree. The style tree also supports logical grouping of targets using "AND" and "OR" nodes.&nbsp; This speeds up and simplifies the CSS syntax generation considerably compared to direct text entry.</p><p></p><h2>Designing a User Interface</h2><h3><b>Resource and Instance trees</b></h3><p>XIDE uses a very simple paradigm. Essentially, it consists of three elements.</p><p></p><ol><li>&nbsp;A resources tree, showing the available widgets (visual and non visual)</li><li>&nbsp;A system design tree and object property inspector/editor</li><li>&nbsp;A layout panel showing a WYSIWYG version of the current page design.</li></ol><p></p> <p>The UI is built by pasting nodes from the resource tree to the system design tree. Each node has object properties defined by a name/value pairs that can be edited using the object inspector or referenced and or updated by run time code. Events are also available on each widget so that Pascal code can be attached to them using the built in code editor and compiler. Python scripts can also be called from these event handlers.</p><h3><b>Available Widgets</b></h3><p>The widgets listed in the resource tree include both UI and non visual components (the latter can be added to the root node of the UI design tree).&nbsp;</p><h3><b>Responsive Design</b></h3><p>XIDE supports a simple Responsive Design layout paradigm which consists of a Main page, Tab controls and Popups to define the constituent pages in a UI design. Horizontal and Vertical layout boxes (together with associated alignment properties) are then nested within these pages to control the final layout of components on the page.</p><h3><b>Writing Application Code</b></h3><p>XIDE uses an event driven model where event handlers can be attached to pre-defined events triggered by objects in the user interface. These procedures can be inspected and/or edited by using the object inspector to navigate to the required UI object then pressing the ellipsis button to the right of the required event in its events tab. This creates an entry for that event handler under the "Event Handlers" node in the code design tree. So once a handler has been added it can then also be navigated to by selecting it in the code designer and pressing the edit button.&nbsp;</p><h3><b>Pascal Syntax</b></h3><p>The Pascal syntax recognised by XIDE&nbsp;is that used by the Pas2JS variant of Free Pascal. (<a href="http://wiki.freepascal.org/pas2js">http://wiki.freepascal.org/pas2js</a>). A detailed description of the supported syntax can be found here. (<a href="http://wiki.freepascal.org/pas2js#RTL">http://wiki.freepascal.org/pas2js#RTL</a>)</p><h3><b>Unit Structure</b></h3><p>In addition to the event handler nodes, shared code can be written by adding units directly to the code design tree as "Pascal Units" or "Python Scripts".&nbsp;&nbsp;</p><p>Functions and procedures&nbsp; in the code nodes can be amended or deleted by selecting the node on the code design tree and pressing the "Edit" button which will bring up the code editor screen as previously described for&nbsp; the event handler code. After a Pascal unit has been compiled for the first time in a session, all the procedures and functions declared in it are displayed as its child nodes in the code design tree. Selecting one of these nodes and pressing the edit button below will navigate directly to that function. Alternatively, selecting a node and pressing "Code Search" will list all references to that function or procedure allowing you to navigate directly to the most relevant reference.</p><h3><b>Python&nbsp;</b></h3><p>The Python syntax used is version 3.8.&nbsp;</p><p>Python does not have a unit structure like Pascal, however blocks of Python code can be added to the Code Designer tree in the same way as Pascal units. The difference is that these will be run&nbsp; when entering run mode. They are executed in the order they occur on the Code Designer tree and can contain initialisation, declarations and / or&nbsp; any other valid executable Python Code.&nbsp;</p><p>To execute Python code elsewhere, such as in an event handler, then simply invoke the "RunPython(<i>......</i>)" procedure with the relevant python function call (or code) as a string parameter,</p><p>A console output box is supplied so that Python errors and print statements can be viewed. On the desktop, the copy of Python being used is the version installed on the host machine, see the documentation for that system to review valid syntax, permissions etc. In the browser, the version of Python used is that supported by mozilla (see&nbsp;<a href="https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/">https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/</a>)</p><h3><b>Accessing user interface objects at run time</b></h3><p>XIDE is designed to be a cross platform rapid application development system. In order to do this it uses a text based system description tree (The System Design or Instance Tree) to reflect the state of a users program at all times. This is similar to the function of the Document Object Model (DOM) in standard web applications. All object properties for nodes on this tree can be accessed and updated using the supplied get and set calls (see below).</p> <h3><b>Types of API Calls</b></h3><p>In XIDE design mode the instance tree describing a users project can be inspected manually using the Object Inspector. This allows the user to select any node on the tree and inspect and/or modify its properties or event handlers as required. The XIDE&nbsp;API allows the same actions to be available programmatically. The functions available fall into the following types (and work in an identical manner in both Pascal and Python) viz:-</p><p></p><ul><li>&nbsp;Dialog boxes</li><li>&nbsp;Get and/or set a property value of a UI object</li><li>&nbsp;Save and load user selected data to the clipboard or local storage</li><li>&nbsp;Copy or delete a UI component or move it to a new parent.</li><li>&nbsp;Show or hide a popup form.</li><li>&nbsp;Show or hide a busy indicator.</li><li>&nbsp;get and set GPU parameters&nbsp;</li></ul><p></p><p>The detailed syntax for these function calls is appended below. Note that unless explicitly stated, all values are strings.</p><h3><b>Asynchronous Calls, Multi Threading and Initialization functions</b></h3><p>Many web calls issue requests that need to wait for a response from a web service, database or other remote service provider. Similarly, when starting another thread in parallel, the main thread will often need to wait for such child threads to return the results of their work before it can proceed. XIDE&nbsp;allows main event handlers to specify a "initalisation"function. This is a block of code which issues all such requests prior to running the main event code when they have all finished executing. See below for the detail syntax of the available calls.</p><p>Note however that all such asynchronous calls first parameter is "e" the event context (automatically declared and populated by XIDE, behind the scenes, for every XIDE&nbsp;event) from which they have been issued so they know where to return without requiring the user to enter complex boilerplate code.</p><h2><b>List of&nbsp;XIDE&nbsp;specific API procedure and function calls</b></h2> <p></p><h3>General Functions</h3><ul><li>procedure SetPropertyValue(nodeName,propName,newValue:String);&nbsp;&nbsp;&nbsp; &nbsp;<font color="#0000ff">set a component property (string value)&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;GetPropertyValue(nodeName,propName:String);&nbsp;<font color="#0000ff">&nbsp; &nbsp;returns a component property value (as string)&nbsp;</font></li><li>procedure SetPropertyValueIndexed(nodeName,propName:String;newValue:TStringArray; x,y:integer);&nbsp;&nbsp; &nbsp;<font color="#0000ff">set a portion of a component array property</font>&nbsp;&nbsp;</li><li>procedure CopyToClip(str:String);&nbsp;&nbsp;<font color="#0000ff">&nbsp;copies the given string to the clipboard&nbsp;</font></li><li>function&nbsp; &nbsp;CopyFromClip(e:TEventStatus):String;&nbsp;&nbsp;&nbsp;<font color="#0000ff">CopyFromClip is an async function (required for browser use), so it must be coded in the&nbsp;&nbsp;''Init'' section of an event handler. The result here is a blank string.&nbsp;&nbsp;&nbsp;The clipboard string is held in e.ReturnString, which can be picked up in the&nbsp;&nbsp;&nbsp; &nbsp;''Main'' section of the event handler.</font></li><li>procedure ShowXForm(XFormID:String; modal:Boolean);&nbsp;&nbsp;<font color="#0000ff">&nbsp;opens a TXForm. [note:''modal=false'' currently only effective on desktop]&nbsp;</font></li><li>procedure CloseXForm(XFormID:String);&nbsp;&nbsp;<font color="#0000ff">&nbsp;closes a TXForm.&nbsp;&nbsp;</font></li><li>procedure DoEvent(EventType,NodeId,myValue:String);&nbsp;<font color="#0000ff"> executes the event handler defined for the given event type and component.&nbsp;</font></li><li>procedure MoveComponent(nodeId:string;NewParentId:string);&nbsp;&nbsp;<font color="#0000ff">re-parents the given UI component&nbsp;</font></li><li>procedure CopyComponent(nodeId,NewParentId,NewName:string);&nbsp;<font color="#0000ff">copies the given UI component and places the clone under the given parent&nbsp;</font></li><li>function&nbsp; &nbsp;DeleteComponent(nodeId:string;ShowNotFoundMsg:Boolean=true):Boolean;&nbsp;&nbsp; <font color="#0000ff">&nbsp;deletes the given UI component. Returns false if not done.&nbsp;</font></li><li>function&nbsp; &nbsp;UserSystemAsString():String;&nbsp; <font color="#0000ff">Returns the string representation of the current user system (can be imported to XIDE via System&gt;Load)&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;LoadUserSystemString(SystemString:String);&nbsp;&nbsp;<font color="#0000ff">Imports a new user system to the XIDE framework (can only be done in ''Design'' mode)&nbsp;</font></li><li>procedure ShowBusy(e:TEventStatus);&nbsp;&nbsp;<font color="#0000ff">Shows the busy cursor&nbsp;ShowBusy is an async function (required for browser use), so it must be coded in the&nbsp; ''Init'' section of an event handler.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></li><li>procedure HideBusy;&nbsp; &nbsp;<font color="#0000ff">Hides the busy cursor&nbsp;</font>&nbsp;</li><li>procedure ProcessMessages;&nbsp; <font color="#0000ff">&nbsp;Functional in Desktop execution only.&nbsp; Executes a pascal Application.ProcessMessages statement.&nbsp;&nbsp;</font></li><li>procedure DebugStart;&nbsp; &nbsp;<font color="#0000ff">Functional in Browser execution only.&nbsp; Executes a Javascript ''debugger;'' statement - starts the native browser debug facility.&nbsp;&nbsp;</font></li><li>procedure RunPython(str:String);&nbsp;<font color="#0000ff">&nbsp;Executes the given Python script&nbsp;</font></li><li>procedure PyodideLoadPackage(nm:String);&nbsp;<font color="#0000ff">&nbsp;Functional in Browser execution only.&nbsp; Loads the requested Pyodide/python package, so that it will be available for import.&nbsp;</font></li><li>function PyodidePackageLoaded(nm:String):Boolean;&nbsp;<font color="#0000ff">&nbsp;Functional in Browser execution only.&nbsp; Returns true if the named package has been loaded into the Pyodide environment.&nbsp;&nbsp;</font>&nbsp; &nbsp;</li></ul><div contenteditable="true"><ul></ul><h3>Messages and Dialogs</h3><ul><li>procedure ShowMessage(msg:String);&nbsp; <font color="#0000ff">&nbsp;displays a popup alert&nbsp;</font></li><li>function&nbsp; &nbsp;Confirm(TextMessage:string):boolean;&nbsp;&nbsp;<font color="#0000ff">displays a confirmation alert; returns true/false&nbsp;</font></li><li>function&nbsp; &nbsp;Prompt(TextMessage,promptString:string):string;&nbsp;&nbsp;&nbsp;<font color="#0000ff">displays an input box; returns user-entered string&nbsp;</font></li><li>procedure ConsoleLog(txt:String);&nbsp; <font color="#0000ff">Writes a debug message to the console log&nbsp;&nbsp;</font></li></ul><ul></ul><h3>TXTable Functions</h3><ul><li>procedure&nbsp; LoadTableFromExcelCopy(TableName,CopiedString:String);&nbsp;&nbsp;<font color="#0000ff">Populate the given TXTable component with a string in Excel format (eg. as copied from a spreadsheet)&nbsp;&nbsp;</font></li><li>procedure&nbsp; LoadTableFromNumArray(TableName,NumArray:T2DNumArray);&nbsp;&nbsp;<font color="#0000ff">Populate the given TXTable component from a 2D numeric array&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;GetTableDataArray(TableName:String;SkipHeader:Boolean):T2DStringArray;&nbsp;&nbsp;<font color="#0000ff">&nbsp;Fetch the cells from the given TXTable component as a 2D string array&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;Array2DToString(arr:T2DNumArray):String;&nbsp; <font color="#0000ff">&nbsp;Convert numeric 2D array to string form eg. [[...],...,[...]]&nbsp;&nbsp;</font></li></ul><ul></ul><h3>TXGPUCanvas Functions</h3><ul><li>function&nbsp; &nbsp;GetGPUParamNumValue(GPUName,pName:String):TNumArray;&nbsp;&nbsp;<font color="#0000ff">For the given TXGPUCanvas component, returns the value of the named numeric parameter as an array&nbsp;</font></li><li>function&nbsp; &nbsp;GetGPUConstIntValue(GPUName,pName:String):integer;&nbsp; <font color="#0000ff">&nbsp;For the given TXGPUCanvas component, returns the value of the named integer parameter&nbsp;</font></li><li>procedure SetGPUParamNumValue(GPUName,pName:String;pValue:TNumArray);&nbsp;&nbsp;<font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named numeric parameter as a 1-D array&nbsp;</font></li><li>procedure SetGPUParam2DNumValue(GPUName,pName:String;pValue:T2DNumArray);&nbsp; &nbsp;<font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named numeric parameter as a 2-D array&nbsp;</font></li><li>procedure SetGPUConstIntValue(GPUName,pName:String;pValue:integer);&nbsp; &nbsp; <font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named integer parameter&nbsp;</font></li><li>function&nbsp; &nbsp;GetGPUPixelArray(GPUName:String):T3DNumArray;&nbsp;&nbsp;<font color="#0000ff">&nbsp;Fetch the current Pixel array for the given TXGPUCanvas component&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;GetGPUPixelArrayAsString(GPUName:String):String;&nbsp;&nbsp;<font color="#0000ff">Fetch the current Pixel array in string format for the given TXGPUCanvas component&nbsp;</font>&nbsp;</li><li>function&nbsp; &nbsp;GetGPUStageArray(GPUName:String):T3DNumArray;&nbsp;&nbsp;&nbsp;<font color="#0000ff"> Fetch the stage array (resulting from the non-graphical kernel stack) for the given </font>TXGPUCanvas component&nbsp;&nbsp;</li><li>function&nbsp; &nbsp;GetGPUStageArrayAsString(GPUName:String):String;&nbsp; &nbsp;<font color="#0000ff">Fetch the stage array in string format for the given TXGPUCanvas component&nbsp;&nbsp;</font></li></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><h3>&nbsp;Python Only</h3><ul><li>function&nbsp; ShowPythonPlot(ImgName,fig)<font color="#0000ff">&nbsp; In the given TXImage component, displays the contents of fig (a matplotlib figure)&nbsp;</font></li></ul><h2>Composite Components</h2><p>XIDE can be used to build reusable ''widgets'' by creating a system with a set of XIDE elements and associated events, and then encapsulating that system. The encapsulated system is saved to local storage, and will appear in the Resources tree as a Composite component, which can then be pasted into other systems the user is building.</p><h3>To Create a Composite Component</h3><p></p><ol><li>Clear the system.</li><li>Build your widget in the normal way (for example, a table, with a copy and a paste button, and click events coded).</li><li>Test the system.</li><li>In design mode, select System&gt;Encapsulate on the main menu.&nbsp; Provide a name for the composite component (eg. "TableWithCopyPaste").</li><li>In the Resources Tree, under ''Composites'', your new widget should now be listed.</li></ol><p></p><h3>To Use a Composite Component</h3><p></p><ol><li>Build a new system in the normal way.</li><li>Select a composite component in the Resources Tree, and paste to the system in the normal way.&nbsp;</li></ol><p></p><p>The composite component will be listed in the Design Tree, but without its constituent components - only the enclosing element will be shown. The composite component has two non-editable properties to note:</p><p></p><ul><li>&nbsp; ''CompositeType'', which shows the name with which the composite was originally created.</li><li>&nbsp; ''SourceString'', which contains the definition of the sub-elements within the composite, for system use.</li></ul><p></p><h3>To Edit a Composite Component</h3><p></p><ol><li>Clear the system.</li><li>Select the composite resource in the Resource Tree, and press ''Load''. This will load the composite as a system in design mode.</li><li>When your update is completed, save the composite again using System&gt;Encapsulate on the main menu.</li></ol><p></p><p>NOTE: This will not update any instantiated copies of your composite.&nbsp; To update instantiated copies, load the system(s) containing them, then delete and re-paste the composite.</p><h3>To Pass Data Into a Composite Component</h3><p>By default, events within a composite element have no view of the containing system, and so cannot obtain data from it. So while building a composite component, you can include a Composite Interface element (TXCompositeIntf in the Resources Tree, under Non-Visual components).</p><p></p><ol><li>Paste a composite interface element under the UIRootNode in the design tree.&nbsp;</li><li>In the object inspector Properties tab, press the ''Add'' button.&nbsp; This will create a new property for the interface.&nbsp;&nbsp;</li><li>On the popup screen, enter the property name.</li><li>Use the ''Type'' selector to specify whether the property is ''Input'' or ''Output''. Select ''Input''.</li><li>Enter some brief text to explain to a user of your composite what the purpose of this property is.</li><li>Press ''Done''.</li></ol><p></p><p>The new property is now listed in the properties list for the interface, and can be accessed from event code within the composite. Encapsulate the composite component, and then paste it into a test system. Note that the object inspector for the instantiated composite component has a tab page "Interface", in which your interface property is listed. An input property is editable here, or can be populated programmatically at run time.</p><h3>To Get Data Out of a Composite Component</h3><p>Events in the enclosing system have no view of the sub-elements within a composite, and so cannot obtain property values directly.&nbsp; For this purpose an ''output'' property is needed. As in the section above, while editing the composite component, add an interface property, and set its type to ''Output''. When your composite is pasted into a containing system, the output property is listed in the Interface tab, but cannot be&nbsp; edited there.&nbsp; It is the responsibility of events within the composite to set the property value.&nbsp;&nbsp;</p><h3>To add a callable Method to a Composite Component</h3><p>While editing your composite system in design mode, select your interface component (TXCompositeIntf) in the design tree.</p><p></p><ol><li>On the ''Events'' tab, press ''Add'' to create a new method.</li><li>On the popup screen, enter the name of the method, and its type (select ''Read-Only'').</li><li>Enter some brief text to explain to a user of your composite what the purpose of this method is.</li><li>Press ''Done''.</li></ol><p></p><p>The new method is now listed in the events list for the interface. Encapsulate the composite component, and then paste it into a test system. Note that the object inspector for the instantiated composite component has your method listed under ''Events'', but cannot be edited here. The enclosing system can execute the method using the ''DoEvent'' built-in.</p><h3>To add an editable Event Handler to a Composite Component</h3><p>While editing your composite system in design mode, select your interface component (TXCompositeIntf) in the design tree.</p><p></p><ol><li>On the ''Events'' tab, press ''Add'' to create a new method.</li><li>On the popup screen, enter the name of the method, and its type (select ''Editable'').</li><li>Enter some brief text to explain to a user of your composite what event within the composite will execute it.</li><li>Press ''Done''.</li></ol><p></p><p>The new event handler is now listed in the events list for the interface, but code cannot be added here. The composite system can execute the method using the ''DoEvent'' built-in, for example on closing a form, or on changing a data table. Encapsulate the composite component, and then paste it into a test system. Note that the object inspector for the instantiated composite component has your event handler listed under ''Events'', and can be edited here, so that the user of the composite component can create their own handler.</p><h2><b>Project Development and Deployment</b></h2><p>During the development phase of a project XIDE&nbsp;will usually be loaded in design mode where you can edit the user interface design and the code behind it. On startup on the desktop, the IDE re-loads the project you were last working on. On the browser, it can be set to revert to the original state every time the app is started or to reload from the previous session.</p><p>Existing projects can be loaded from a previously saved system in local storage, or from the clipboard. Clearing the current system will start a new project. At the end of the design phase, you will sometimes want to deploy the developed HTML app to end users without allowing access to the IDE. In this case, select the "System / Deploy" option from the main menu and this will generate a self contained HTML page implementing your application and the run time environment needed to execute it, but with the interactive IDE features disabled. You can now load this to a server of your choice, or email directly to your end user so they can run it from their file system.&nbsp;</p><p>Alternatively, if you wish to give them access to inspect and perhaps contribute to, or modify, the app, then distribute the blank XIDE app for their preferred platform&nbsp; and use the "System / Save" option to generate a project definition file that they can load into it using the "System / Load" option on the main menu.&nbsp;</p><h2><b>Debugging</b></h2><p>When testing Pascal code you have written using XIDE, the PAS2JS compiler error messages will flag any source code syntax problems. If you click on one of these error messages this will position the cursor at the relevant character position in the line of code in the XIDE&nbsp;code editor. Run time errors will sometimes be trapped by error handlers built in to XIDE&nbsp;and generate a helpful error message. If this is not sufficient to uniquely identify the cause of the problem then "ctrl shift J" in Chrome will bring up the built in developer console which will hopefully provide the additional information you need to track down the problem. Alternatively, a break point can be set in the code by inserting a "DebugStart;" instruction that will start the native browser debug facility at that point.</p><h2>Implementation, Extensibility and Licensing</h2><p>XIDE is implemented using the Pas2JS dialect of the Object Pascal programming language. This is because it is efficient, easy to learn, and is available on a wide range of processor architectures.&nbsp;</p><p>Sometimes, as projects go through their life cycle, new more specialist requirements emerge. At this point the XIDE framework can be extended using project or platform specific custom components developed in Lazarus.&nbsp;</p><p>XIDE is an open source project distributed using the same licence as Lazarus (GPL) Source code is available from GitHub&nbsp; see <a href="https://github.com/Steve--W/XIDE">here</a> for the IDE and&nbsp;<a href="https://github.com/Steve--W/XComponents">here</a> for the components used to build it. (see <font color="#0000ff">https://github.com/Steve--W/XIDE</font> and<font color="#0000ff"> https://github.com/Steve--W/XComponents</font> respectively)</p><h2>Development Roadmap</h2><p>I have developed XIDE&nbsp; to support my ongoing academic research projects. I have made the project open source in case it should prove useful to anyone else. In particular, I hope its browser first approach, low installation overhead and easy learning curve will help to introduce the&nbsp; joys of Free Pascal and Lazarus to a wider audience.<br></p><p>Those aspects of XIDE and XComponents that I use regularly are "tried and tested". Some aspects that are used less often may have more bugs, and there are many aspects where it would be great to add new or improved features but where I do not have the bandwidth to address at the moment. If&nbsp; anyone wants to help out with any improvement to XIDE then their contribution will be most welcome.</p><p>(Some topics that spring to mind, from a long list of potential improvements, are:-&nbsp; Broadening XIDE browser support beyond the Chrome compatible set, XIDE integration with Lazarus, improving the wrapper for GPUJS or adding a drag and drop utility for constructing MatPlotLib data visualisations to make these Python libraries easily accessible to the Pascal community. )</p><h2>Compatibility</h2><p>In desktop mode, XIDE is designed to run on platforms supported by&nbsp; Lazarus, and optionally, the&nbsp; Chromium Embedded Framework and&nbsp; Python (i.e. most desktop platforms). If CEF or Python is not available then XIDE can still run but will then not support their specialist features.&nbsp; Alternatively, Electron or Cordova and Crosswalk can be used to provide a hybrid implementation of XIDE. This gives full Web connectivity and CSS on a wide range of platforms but with a trade off in terms of size, speed and security.</p><p>In browser mode XIDE is targeting closed user groups (where the browser can be specified) so it is only tested on recent versions of Chrome but it may also work on other browsers which use a Chrome engine. (e.g. the latest version of Microsoft Edge)&nbsp;</p><p>Note that the Style Designer is only available on the Browser versions as it depends on CSS functionality.</p><h2>Motivation for including a GPU capability in XIDE</h2><p>XIDE provides a thin wrapper for GPUJS (See https://gpu.rocks/) which generates GPU code from JavaScript. This produces WebGL code as it is widely supported "out of the box"&nbsp; in most browsers and on most processor/GPU combinations. This minimises the&nbsp; installation and configuration needed in order to get GPU code running on a new system. As such it is a good way to start learning about the possibilities (and perhaps more importantly the limitations) of programming for a massively parallel platform.&nbsp;</p><p>One of the weaknesses of this approach is the frustrating inability to optimise code or diagnose bugs in the GPU kernels except by exhaustive trial and error.&nbsp; So for any serious GPU programming it is well worth investing the time in getting to grips with the (admittedly intimidating) learning curve needed to master tools like OpenCL or Cuda and the associated tool stacks. Having said that, for simple "embarrassingly parallel" examples, or where there is a need to build simple GPU code into more general purpose or widely shared apps, the GPUJS approach can be very helpful.</p><h2>The XIDE GPUJS Wrapper</h2><p>The Pascal code for the GPU is accessed as a property of a GPU Canvas component which has been dropped onto the User Interface layout screen and/or as a node on the Code designer tree.&nbsp; The Pascal GPU code editor follows the same edit/compile cycle as for user code in the rest of the system. The differences are that this is code for blocks of threads in parallel. The code describes a single instruction multiple data (SIMD) approach where all the threads run the same code with thread specific code referencing "this.thread.x" , "this.thread.y" and "this.thread.z" to reflect their position in the block of threads. Parameter names are declared using a Paramlist property of the GPU canvas component and their transfer and run time execution is controlled by system calls described below. (N.B. parameters need to be passed as arrays so even scalar parameters passed into the code need to be referenced as follows "myParam[0]" )<br></p><p>The Pascal GPU code can daisy chain kernels. (Set the TXGPUCanvas property NumKernels&gt;0) For each kernel in the chain its return value must be set to "MyValue". The next kernel in the chain can then read all the thread return values from the previous kernel by reading from "MyArray".The initial "MyArray" passed to the first kernel in the chain is set as a property ("InitStageData") of the GPU canvas and can have any x,y,z sizes as chosen by the user. The final&nbsp; &nbsp;kernel is the graphics display kernel where you set the r,g,b values as usual. The calculated data input to the graphics display kernel can also be accessed using either the "GetGPUStageArray" or "GetGPUStageArrayAsString" instructions;</p><p>Maths functions available in the GPU code are as follows:-</p><p></p><ul><li>abs(a) sign(a) trunc(a) ceil(a) max(a,b) min(a,b)</li><li>sin(a) cos(a) arcsin(a) arccos(a) arctan(a,b)</li><li>sqrt(a) power(a,b) ln(a) log10(a) log2(a)&nbsp;</li></ul><h2>Limitations of coding for the GPU&nbsp;</h2><p>When coding in Pascal for the GPU, you should be aware that there are fundamental limitations on the constructs available. In particular:-</p><p></p><ul><li>All parameters passed into the GPU&nbsp; are real arrays (scalar parameters are real arrays of length one)<br></li><li>You can read from but not write to any of these array parameters</li><li>You cannot declare a local array</li><li>Each thread returns a single real value</li><li>You cannot communicate with any other thread (except by synchronising the results in a new kernel)</li><li>You cannot use a Boolean type (use 0 or 1 instead)</li><li>You cannot use "var" parameters in a function call</li><li>All function parameters must be a simple type</li><li>Nested function declarations do not follow normal (Pascal) scope rules</li><li>Loops are unrolled so you MUST SET the "<span style="font-family: Verdana, Arial, sans-serif; font-size: 12px; white-space: nowrap;">MaxIterations"</span>&nbsp;parameter at a high enough value to reflect your algorithm''s requirements</li><li>The number of threads in each kernel are given by the KernelXDims, KernelYDims and Kernel ZDims properties of the GPU Canvas and these MUST BE SET either manually or programatically before activating the GPU.</li><li>The GPU is a Single Instruction Multiple Data machine so branching in a thread does not jump over the code in the path not taken,&nbsp; it idles in order to allow other threads to execute the code in that path if need be.&nbsp;</li><li>Debugging on the GPU is "primitive" the only way to do it when running on the hardware is to write out intermediate results&nbsp; to the thread output value for selected threads which you dedicate to providing diagnostic output.&nbsp;</li></ul><p><br></p><p><br></p><p></p>';
'<h1 style="text-align: center;"><u>XIDE Help</u></h1><h2 style="text-align: center;">&nbsp;(A simple "Browser-First" IDE for Pascal and Python)</h2><h2>Contents</h2><p>Overview</p><p></p><ul><li><a href="#Purpose">Purpose</a></li><li><a href="#Installation">Installation</a></li><li><a href="#Functionality">Functionality</a></li><li><a href="#UnifiedUserInterface(HTML,CSS,SVG)">Unified User Interface (HTML,CSS,SVG)</a></li><li><a href="#TheStyleDesigner">The Style Designer</a></li><li><a href="#CompositeComponents">Composite Components</a></li><li><a href="#GPUCapability">GPU Capability</a></li><li><a href="#ProjectDevelopmentandDeployment">Project Development and Deployment</a></li><li><a href="#Debugging">Debugging</a></li><li><a href="#ImplementationExtensibilityandLicencing">Implementation, Extensibility and Licencing</a></li><li><a href="#DevelopmentRoadmap">Development Roadmap</a></li><li><a href="#Compatibility">Compatibility</a></li></ul><p></p><p></p><p>User Interface</p><ul><li><a href="#DesigningaUserinterface">Designing a Userinterface</a></li><li><a href="#ResourceandInstanceTrees">Resource and InstanceTrees</a></li><li><a href="#AvailableWidgets">Available Widgets</a></li><li><a href="#ResponsiveDesign">Responsive Design</a></li><li><a href="#WritingApplicationCode">Writing Application Code</a></li><li><a href="#PascalSyntax">Pascal Syntax</a></li><li><a href="#Python">Python</a></li></ul><p></p><p>Application Programming Interface</p><p></p><ul><li><a href="#AccessingUserinterfaceObjectsatRunTime">Accessing User interface Objects at Run Time</a></li><li><a href="#TypesofAPICalls">Types of API Calls</a></li><li><a href="#AsynchronousCallsMultithreadingandInitialisationfunctions">Asynchronous Calls,Multithreading and Initialisation functions</a></li><li><a href="#ListofXIDEspecificAPIprocedureandfunctioncalls">List of XIDE specific API procedure and function calls</a></li><li><a href="#Generalfunctions">General functions</a></li><li><a href="#MessagesandDialogs">Messages and Dialogs</a></li><li><a href="#TXTablefunctions">TXTable functions</a></li><li><a href="#TXGPUCanvasfunctions">TXGPU Canvas functions</a></li><li><a href="#PythonOnly">Python Only functions</a></li></ul><p></p><p>Encapsulation</p><ul><li><a href="#TocreateacompositeComponent">To create a composite Component</a></li><li><a href="#TouseacompositeComponent">To use a composite Component</a></li><li><a href="#ToeditacompositeComponent">To edit a composite Component</a></li><li><a href="#TopassdataintoacompositeComponent">To pass data in to a composite Component</a></li><li><a href="#TogetdataoutofacompositeComponent">To get data out of a composite Component</a></li><li><a href="#ToaddacallablemethodtoacompositeComponent">To add a callable method to a composite Component</a></li><li><a href="#ToaddaneditableeventhandlertoacompositeComponent">To add an editable event handler to&nbsp; a composite Component</a></li></ul><p>GPU&nbsp;<br></p><ul><li><a href="#TheXIDEGPUJSWrapper">The XIDE GPUJS Wrapper</a></li><li><a href="#MathsfunctionsavailableintheGPU">Maths functions available in the GPU</a></li><li><a href="#LimitationsofcodingfortheGPU">Limitations of coding for the GPU</a></li></ul><p></p><p></p><p>&nbsp;&nbsp;</p><p></p><hr id="null"><h2><p></p></h2><h2><p><a id="Purpose">Purpose</a><br></p></h2><p>XIDE is a combined Client Side Run Time Library and RAD IDE intended to allow Pascal and/or Python development in the browser with the minimum of installation overhead or learning curve while also being as platform independent as possible. It is targeted at Prototyping, Small Group Collaboration and Agile Line of Business projects on any platform that is supported by Chrome or Electron, or Lazarus (and the Chrome Embedded Framework).&nbsp; It is not intended for the development of general-purpose public facing web sites.</p><h2><a id="Installation">Installation</a><br></h2><p>In the browser, XIDE for Chrome is a single page static HTML page with no dependencies. so installation is just a matter of loading that initial web page. All subsequent computation and data storage is done client side. This single page web app&nbsp; combines the currently selected user project, as well as the RTL and IDE Code so any user project can be deployed with the IDE disabled (for end users) or enabled (for collaborators) as required.</p><p>Python in XIDE is based on the Mozilla Pyodide project which brings a full data science stack to the browser, such as NumPy, Pandas and Matplotlib.&nbsp;</p><p>If using a snapshot of XIDE on the desktop (i.e. XIDE.exe), you need to&nbsp; install local copies of Free Pascal and Python following the relevant instructions on their web sites. Then using the XIDE.exe main menu "Settings" option set the path to the home directories for the fpc compiler. Alternatively to rebuild XIDE from source, see&nbsp;&nbsp;<a href="https://github.com/Steve--W/XIDE">https://github.com/Steve--W/XIDE.</a>&nbsp;</p><h2><a id="Functionality">Functionality</a><br></h2><p>XIDE is designed to bring the power of Free Pascal (Pas2JS) and the convenience of&nbsp; Rapid Application Development (RAD) to the browser. It&nbsp; is a "Browser First" approach which also delivers cross platform capability by replicating browser functionality on the desktop in native code. This allows the user to exploit the greater efficiency of compiled native code compared to interpreted browser environments as required. It also allows a single code base to support multiple different target environments for different user circumstances or different stages in a project.&nbsp;</p><p>The Python option in XIDE adds broader "Data Science" capabilities to the environment and&nbsp; allows the more interactive exploratory approach of Python to be exploited as required. See&nbsp;&nbsp;<a href="https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/">https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/</a></p><h2><a id="UnifiedUserInterface(HTML,CSS,SVG)">Unified User Interface (HTML,CSS,SVG)</a><br></h2><p>The browser supports a number of different standards as part of its user interface. These include HTML, CSS, SVG&nbsp; to cover page layout, style editing, and vector graphics respectively. Normally these all require their own conventions to be used when accessed directly from the browser and/or JavaScript. XIDE unifies the user''s access to these different browser capabilities using a standardised Object Inspector / Drag and Drop approach for them all. For HTML and SVG this should appear seamless to the user with all the SVG containers and components accessed in an identical manner to HTML so requiring no further explanation than provided below for basic screen layout and editing.&nbsp;</p><h2><a id="TheStyleDesigner">The Style Designer</a><br></h2><p>CSS functionality is provided by supporting a style design tree in addition to the Code and UI design trees described below. As with the UI design tree, Style resources (new design rules, targets, properties and rule types ) are dragged from a resources tree and dropped on the relevant node of the style tree. The style tree also supports logical grouping of targets using "AND" and "OR" nodes.&nbsp; This speeds up and simplifies the CSS syntax generation considerably compared to direct text entry.</p><h2><a id="CompositeComponents">Composite Components</a><br></h2><p>XIDE can be used to build reusable "widgets" by creating a system with a set of XIDE elements and associated events, and then encapsulating that system. The encapsulated system is saved to local storage, and will appear in the Resources tree as a Composite component, which can then be pasted into other systems the user is building.</p><h2><a id="GPUCapability">GPU Capability</a><br></h2><p>XIDE provides a thin wrapper for GPUJS (See https://gpu.rocks/) which generates GPU code from JavaScript. This produces WebGL code as it is widely supported "out of the box"&nbsp; in most browsers and on most processor/GPU combinations. This minimises the&nbsp; installation and configuration needed in order to get GPU code running on a new system. As such it is a good way to start learning about the possibilities (and perhaps more importantly the limitations) of programming for a massively parallel platform.&nbsp;</p><p>One of the weaknesses of this approach is the frustrating inability to optimise code or diagnose bugs in the GPU kernels except by exhaustive trial and error.&nbsp; So for any serious GPU programming it is well worth investing the time in getting to grips with the (admittedly intimidating) learning curve needed to master tools like OpenCL or Cuda and the associated tool stacks. Having said that, for simple "embarrassingly parallel" examples, or where there is a need to build simple GPU code into more general purpose or widely shared apps, the GPUJS approach can be very helpful.</p><h2><a id="ProjectDevelopmentandDeployment">Project Development and Deployment</a><br></h2><p>During the development phase of a project XIDE&nbsp;will usually be loaded in design mode where you can edit the user interface design and the code behind it. On startup on the desktop, the IDE re-loads the project you were last working on. On the browser, it can be set to revert to the original state every time the app is started or to reload from the previous session.</p><p>Existing projects can be loaded from a previously saved system in local storage, or from the clipboard. Clearing the current system will start a new project. At the end of the design phase, you will sometimes want to deploy the developed HTML app to end users without allowing access to the IDE. In this case, select the "System / Deploy" option from the main menu and this will generate a self contained HTML page implementing your application and the run time environment needed to execute it, but with the interactive IDE features disabled. You can now load this to a server of your choice, or email directly to your end user so they can run it from their file system.&nbsp;</p><p>Alternatively, if you wish to give them access to inspect and perhaps contribute to, or modify, the app, then distribute the blank XIDE app for their preferred platform&nbsp; and use the "System / Save" option to generate a project definition file that they can load into it using the "System / Load" option on the main menu.&nbsp;</p><h2><a id="Debugging">Debugging</a><br></h2><p>When testing Pascal code you have written using XIDE, the PAS2JS compiler error messages will flag any source code syntax problems. If you click on one of these error messages this will position the cursor at the relevant character position in the line of code in the XIDE&nbsp;code editor. Run time errors will sometimes be trapped by error handlers built in to XIDE&nbsp;and generate a helpful error message. If this is not sufficient to uniquely identify the cause of the problem then "ctrl shift J" in Chrome will bring up the built in developer console which will hopefully provide the additional information you need to track down the problem. Alternatively, a break point can be set in the code by inserting a "DebugStart;" instruction that will start the native browser debug facility at that point.</p><h2><a id="ImplementationExtensibilityandLicencing">Implementation, Extensibility and Licensing</a><br></h2><p>XIDE is implemented using the Pas2JS dialect of the Object Pascal programming language. This is because it is efficient, easy to learn, and is available on a wide range of processor architectures.&nbsp;</p><p>Sometimes, as projects go through their life cycle, new more specialist requirements emerge. At this point the XIDE framework can be extended using project or platform specific custom components developed in Lazarus.&nbsp;</p><p>XIDE is an open source project distributed using the same licence as Lazarus (GPL) Source code is available from GitHub&nbsp; see&nbsp;<a href="https://github.com/Steve--W/XIDE">here</a>&nbsp;for the IDE and&nbsp;<a href="https://github.com/Steve--W/XComponents">here</a>&nbsp;for the components used to build it. (see&nbsp;<font color="#0000ff">https://github.com/Steve--W/XIDE</font>&nbsp;and<font color="#0000ff">&nbsp;https://github.com/Steve--W/XComponents</font>&nbsp;respectively)</p><h2><a id="DevelopmentRoadmap">Development Roadmap</a><br></h2><p>I have developed XIDE&nbsp; to support my ongoing academic research projects. I have made the project open source in case it should prove useful to anyone else. In particular, I hope its browser first approach, low installation overhead and easy learning curve will help to introduce the&nbsp; joys of Free Pascal and Lazarus to a wider audience.<br></p><p>Those aspects of XIDE and XComponents that I use regularly are "tried and tested". Some aspects that are used less often may have more bugs, and there are many aspects where it would be great to add new or improved features but where I do not have the bandwidth to address at the moment. If&nbsp; anyone wants to help out with any improvement to XIDE then their contribution will be most welcome.</p><p>(Some topics that spring to mind, from a long list of potential improvements, are:-&nbsp; Broadening XIDE browser support beyond the Chrome compatible set, XIDE integration with Lazarus, improving the wrapper for GPUJS or adding a drag and drop utility for constructing MatPlotLib data visualisations to make these Python libraries easily accessible to the Pascal community. )</p><h2><a id="Compatibility">Compatibility</a><br></h2><p>In desktop mode, XIDE is designed to run on platforms supported by&nbsp; Lazarus, and optionally, the&nbsp; Chromium Embedded Framework and&nbsp; Python (i.e. most desktop platforms). If CEF or Python is not available then XIDE can still run but will then not support their specialist features.&nbsp; Alternatively, Electron or Cordova and Crosswalk can be used to provide a hybrid implementation of XIDE. This gives full Web connectivity and CSS on a wide range of platforms but with a trade off in terms of size, speed and security.</p><p>In browser mode XIDE is targeting closed user groups (where the browser can be specified) so it is only tested on recent versions of Chrome but it may also work on other browsers which use a Chrome engine. (e.g. the latest version of Microsoft Edge)&nbsp;</p><p>Note that TheStyleDesigner is only available on the Browser versions as it depends on CSS functionality.</p><p><br></p><hr id="null"><p></p><h2><a id="DesigningaUserinterface">Designing a User interface</a><br></h2><h3><a id="ResourceandInstanceTrees">Resource and Instance Trees</a><br></h3><p>XIDE uses a very simple paradigm. Essentially, it consists of three elements.</p><p></p><ol><li>&nbsp;A resources tree, showing the AvailableWidgets (visual and non visual)</li><li>&nbsp;A system design tree and object property inspector/editor</li><li>&nbsp;A layout panel showing a WYSIWYG version of the current page design.</li></ol><p></p> <p>The UI is built by pasting nodes from the resource tree to the system design tree. Each node has object properties defined by a name/value pairs that can be edited using the object inspector or referenced and or updated by run time code. Events are also available on each widget so that Pascal code can be attached to them using the built in code editor and compiler. Python scripts can also be called from these event handlers.</p><h3><a id="AvailableWidgets">Available Widgets</a><br></h3><p>The widgets listed in the resource tree include both UI and non visual components (the latter can be added to the root node of the UI design tree).&nbsp;</p><h3><a id="ResponsiveDesign">Responsive Design</a><br></h3><p>XIDE supports a simple ResponsiveDesign layout paradigm which consists of a Main page, Tab controls and Popups to define the constituent pages in a UI design. Horizontal and Vertical layout boxes (together with associated alignment properties) are then nested within these pages to control the final layout of components on the page.</p><h3><a id="WritingApplicationCode">Writing Application Code</a><br></h3><p>XIDE uses an event driven model where event handlers can be attached to pre-defined events triggered by objects in the user interface. These procedures can be inspected and/or edited by using the object inspector to navigate to the required UI object then pressing the ellipsis button to the right of the required event in its events tab. This creates an entry for that event handler under the "Event Handlers" node in the code design tree. So once a handler has been added it can then also be navigated to by selecting it in the code designer and pressing the edit button.&nbsp;</p><h3><a id="PascalSyntax">Pascal Syntax</a><br></h3><p>The PascalSyntax recognised by XIDE&nbsp;is that used by the Pas2JS variant of Free Pascal. (<a href="http://wiki.freepascal.org/pas2js">http://wiki.freepascal.org/pas2js</a>). A detailed description of the supported syntax can be found here. (<a href="http://wiki.freepascal.org/pas2js#RTL">http://wiki.freepascal.org/pas2js#RTL</a>)</p><h3><a id="UnitStructure">Unit Structure</a><br></h3><p>In addition to the event handler nodes, shared code can be written by adding units directly to the code design tree as "Pascal Units" or "Python Scripts".&nbsp;&nbsp;</p><p>Functions and procedures&nbsp; in the code nodes can be amended or deleted by selecting the node on the code design tree and pressing the "Edit" button which will bring up the code editor screen as previously described for&nbsp; the event handler code. After a Pascal unit has been compiled for the first time in a session, all the procedures and functions declared in it are displayed as its child nodes in the code design tree. Selecting one of these nodes and pressing the edit button below will navigate directly to that function. Alternatively, selecting a node and pressing "Code Search" will list all references to that function or procedure allowing you to navigate directly to the most relevant reference.</p><h3><a id="Python">Python</a><br></h3><p>The Python syntax used is version 3.8.&nbsp;</p><p>Python does not have a unit structure like Pascal, however blocks of Python code can be added to the Code Designer tree in the same way as Pascal units. The difference is that these will be run&nbsp; when entering run mode. They are executed in the order they occur on the Code Designer tree and can contain initialisation, declarations and / or&nbsp; any other valid executable Python Code.&nbsp;</p><p>To execute Python code elsewhere, such as in an event handler, then simply invoke the "RunPython(<i>......</i>)" procedure with the relevant python function call (or code) as a string parameter,</p><p>A console output box is supplied so that Python errors and print statements can be viewed. On the desktop, the copy of Python being used is the version installed on the host machine, see the documentation for that system to review valid syntax, permissions etc. In the browser, the version of Python used is that supported by mozilla (see&nbsp;<a href="https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/">https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/</a>)</p><p><br></p><hr id="null"><h3><a id="AccessingUserinterfaceObjectsatRunTime">Accessing User interface Objects at Run Time</a><br></h3><p>XIDE is designed to be a cross platform rapid application development system. In order to do this it uses a text based system description tree (The System Design or Instance Tree) to reflect the state of a users program at all times. This is similar to the function of the Document Object Model (DOM) in standard web applications. All object properties for nodes on this tree can be accessed and updated using the supplied get and set calls (see below).</p> <h3><a id="TypesofAPICalls">Types of API Calls</a><br></h3><p>In XIDE design mode the instance tree describing a users project can be inspected manually using the Object Inspector. This allows the user to select any node on the tree and inspect and/or modify its properties or event handlers as required. The XIDE&nbsp;API allows the same actions to be available programmatically. The functions available fall into the following types (and work in an identical manner in both Pascal and Python) viz:-</p><p></p><ul><li>&nbsp;Dialog boxes</li><li>&nbsp;Get and/or set a property value of a UI object</li><li>&nbsp;Save and load user selected data to the clipboard or local storage</li><li>&nbsp;Copy or delete a UI component or move it to a new parent.</li><li>&nbsp;Show or hide a popup form.</li><li>&nbsp;Show or hide a busy indicator.</li><li>&nbsp;get and set GPU parameters&nbsp;</li></ul><p></p><p>The detailed syntax for these function calls is appended below. Note that unless explicitly stated, all values are strings.</p><h3><a id="AsynchronousCallsMultiThreadingandInitializationfunctions">Asynchronous Calls, Multi Threading and Initialization functions</a><br></h3><p>Many web calls issue requests that need to wait for a response from a web service, database or other remote service provider. Similarly, when starting another thread in parallel, the main thread will often need to wait for such child threads to return the results of their work before it can proceed. XIDE&nbsp;allows main event handlers to specify a "initalisation"function. This is a block of code which issues all such requests prior to running the main event code when they have all finished executing. See below for the detail syntax of the available calls.</p><p>Note however that all such asynchronous calls first parameter is "e" the event context (automatically declared and populated by XIDE, behind the scenes, for every XIDE&nbsp;event) from which they have been issued so they know where to return without requiring the user to enter complex boilerplate code.</p><h2><a id="ListofXIDEspecificAPIprocedureandfunctioncalls">List of XIDE specific API procedure and function calls</a><br></h2> <p></p><h3><a id="Generalfunctions">General functions</a><br></h3><ul><li>procedure SetPropertyValue(nodeName,propName,newValue:String);&nbsp;&nbsp;&nbsp; &nbsp;<font color="#0000ff">set a component property (string value)&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;GetPropertyValue(nodeName,propName:String);&nbsp;<font color="#0000ff">&nbsp; &nbsp;returns a component property value (as string)&nbsp;</font></li><li>procedure SetPropertyValueIndexed(nodeName,propName:String;newValue:TStringArray; x,y:integer);&nbsp;&nbsp; &nbsp;<font color="#0000ff">set a portion of a component array property</font>&nbsp;&nbsp;</li><li>procedure CopyToClip(str:String);&nbsp;&nbsp;<font color="#0000ff">&nbsp;copies the given string to the clipboard&nbsp;</font></li><li>function&nbsp; &nbsp;CopyFromClip(e:TEventStatus):String;&nbsp;&nbsp;&nbsp;<font color="#0000ff">CopyFromClip is an async function (required for browser use), so it must be coded in the&nbsp;&nbsp;"Init" section of an event handler. The result here is a blank string.&nbsp;&nbsp;&nbsp;The clipboard string is held in e.ReturnString, which can be picked up in the&nbsp;&nbsp;&nbsp; &nbsp;"Main" section of the event handler.</font></li><li>procedure ShowXForm(XFormID:String; modal:Boolean);&nbsp;&nbsp;<font color="#0000ff">&nbsp;opens a TXForm. [note:"modal=false" currently only effective on desktop]&nbsp;</font></li><li>procedure CloseXForm(XFormID:String);&nbsp;&nbsp;<font color="#0000ff">&nbsp;closes a TXForm.&nbsp;&nbsp;</font></li><li>procedure DoEvent(EventType,NodeId,myValue:String);&nbsp;<font color="#0000ff"> executes the event handler defined for the given event type and component.&nbsp;</font></li><li>procedure MoveComponent(nodeId:string;NewParentId:string);&nbsp;&nbsp;<font color="#0000ff">re-parents the given UI component&nbsp;</font></li><li>procedure CopyComponent(nodeId,NewParentId,NewName:string);&nbsp;<font color="#0000ff">copies the given UI component and places the clone under the given parent&nbsp;</font></li><li>function&nbsp; &nbsp;DeleteComponent(nodeId:string;ShowNotFoundMsg:Boolean=true):Boolean;&nbsp;&nbsp; <font color="#0000ff">&nbsp;deletes the given UI component. Returns false if not done.&nbsp;</font></li><li>function&nbsp; &nbsp;UserSystemAsString():String;&nbsp; <font color="#0000ff">Returns the string representation of the current user system (can be imported to XIDE via System&gt;Load)&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;LoadUserSystemString(SystemString:String);&nbsp;&nbsp;<font color="#0000ff">Imports a new user system to the XIDE framework (can only be done in "Design" mode)&nbsp;</font></li><li>procedure ShowBusy(e:TEventStatus);&nbsp;&nbsp;<font color="#0000ff">Shows the busy cursor&nbsp;ShowBusy is an async function (required for browser use), so it must be coded in the&nbsp; "Init" section of an event handler.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</font></li><li>procedure HideBusy;&nbsp; &nbsp;<font color="#0000ff">Hides the busy cursor&nbsp;</font>&nbsp;</li><li>procedure ProcessMessages;&nbsp; <font color="#0000ff">&nbsp;Functional in Desktop execution only.&nbsp; Executes a pascal Application.ProcessMessages statement.&nbsp;&nbsp;</font></li><li>procedure DebugStart;&nbsp; &nbsp;<font color="#0000ff">Functional in Browser execution only.&nbsp; Executes a Javascript "debugger;" statement - starts the native browser debug facility.&nbsp;&nbsp;</font></li><li>procedure RunPython(str:String);&nbsp;<font color="#0000ff">&nbsp;Executes the given Python script&nbsp;</font></li><li>procedure PyodideLoadPackage(nm:String);&nbsp;<font color="#0000ff">&nbsp;Functional in Browser execution only.&nbsp; Loads the requested Pyodide/python package, so that it will be available for import.&nbsp;</font></li><li>function PyodidePackageLoaded(nm:String):Boolean;&nbsp;<font color="#0000ff">&nbsp;Functional in Browser execution only.&nbsp; Returns true if the named package has been loaded into the Pyodide environment.&nbsp;&nbsp;</font>&nbsp; &nbsp;</li></ul><div contenteditable="true"><ul></ul><h3><a id="MessagesandDialogs">Messages and Dialogs</a><br></h3><ul><li>procedure ShowMessage(msg:String);&nbsp; <font color="#0000ff">&nbsp;displays a popup alert&nbsp;</font></li><li>function&nbsp; &nbsp;Confirm(TextMessage:string):boolean;&nbsp;&nbsp;<font color="#0000ff">displays a confirmation alert; returns true/false&nbsp;</font></li><li>function&nbsp; &nbsp;Prompt(TextMessage,promptString:string):string;&nbsp;&nbsp;&nbsp;<font color="#0000ff">displays an input box; returns user-entered string&nbsp;</font></li><li>procedure ConsoleLog(txt:String);&nbsp; <font color="#0000ff">Writes a debug message to the console log&nbsp;&nbsp;</font></li></ul><ul></ul><h3><a id="TXTablefunctions">TXTable functions</a><br></h3><ul><li>procedure&nbsp; LoadTableFromExcelCopy(TableName,CopiedString:String);&nbsp;&nbsp;<font color="#0000ff">Populate the given TXTable component with a string in Excel format (eg. as copied from a spreadsheet)&nbsp;&nbsp;</font></li><li>procedure&nbsp; LoadTableFromNumArray(TableName,NumArray:T2DNumArray);&nbsp;&nbsp;<font color="#0000ff">Populate the given TXTable component from a 2D numeric array&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;GetTableDataArray(TableName:String;SkipHeader:Boolean):T2DStringArray;&nbsp;&nbsp;<font color="#0000ff">&nbsp;Fetch the cells from the given TXTable component as a 2D string array&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;Array2DToString(arr:T2DNumArray):String;&nbsp; <font color="#0000ff">&nbsp;Convert numeric 2D array to string form eg. [[...],...,[...]]&nbsp;&nbsp;</font></li></ul><ul></ul><h3><a id="TXGPUCanvasfunctions">TXGPU Canvas functions</a><br></h3><ul><li>function&nbsp; &nbsp;GetGPUParamNumValue(GPUName,pName:String):TNumArray;&nbsp;&nbsp;<font color="#0000ff">For the given TXGPUCanvas component, returns the value of the named numeric parameter as an array&nbsp;</font></li><li>function&nbsp; &nbsp;GetGPUConstIntValue(GPUName,pName:String):integer;&nbsp; <font color="#0000ff">&nbsp;For the given TXGPUCanvas component, returns the value of the named integer parameter&nbsp;</font></li><li>procedure SetGPUParamNumValue(GPUName,pName:String;pValue:TNumArray);&nbsp;&nbsp;<font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named numeric parameter as a 1-D array&nbsp;</font></li><li>procedure SetGPUParam2DNumValue(GPUName,pName:String;pValue:T2DNumArray);&nbsp; &nbsp;<font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named numeric parameter as a 2-D array&nbsp;</font></li><li>procedure SetGPUConstIntValue(GPUName,pName:String;pValue:integer);&nbsp; &nbsp; <font color="#0000ff">For the given TXGPUCanvas component, sets the value of the named integer parameter&nbsp;</font></li><li>function&nbsp; &nbsp;GetGPUPixelArray(GPUName:String):T3DNumArray;&nbsp;&nbsp;<font color="#0000ff">&nbsp;Fetch the current Pixel array for the given TXGPUCanvas component&nbsp;&nbsp;</font></li><li>function&nbsp; &nbsp;GetGPUPixelArrayAsString(GPUName:String):String;&nbsp;&nbsp;<font color="#0000ff">Fetch the current Pixel array in string format for the given TXGPUCanvas component&nbsp;</font>&nbsp;</li><li>function&nbsp; &nbsp;GetGPUStageArray(GPUName:String):T3DNumArray;&nbsp;&nbsp;&nbsp;<font color="#0000ff"> Fetch the stage array (resulting from the non-graphical kernel stack) for the given </font>TXGPUCanvas component&nbsp;&nbsp;</li><li>function&nbsp; &nbsp;GetGPUStageArrayAsString(GPUName:String):String;&nbsp; &nbsp;<font color="#0000ff">Fetch the stage array in string format for the given TXGPUCanvas component&nbsp;&nbsp;</font></li></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><ul></ul><h3><a id="PythonOnly">Python Only</a><br></h3><ul><li>function&nbsp; ShowPythonPlot(ImgName,fig)<font color="#0000ff">&nbsp; In the given TXImage component, displays the contents of fig (a matplotlib figure)&nbsp;</font></li></ul><hr id="null"><h2><a id="TocreateacompositeComponent">To create a composite Component</a><br></h2><p></p><ol><li>Clear the system.</li><li>Build your widget in the normal way (for example, a table, with a copy and a paste button, and click events coded).</li><li>Test the system.</li><li>In design mode, select System&gt;Encapsulate on the main menu.&nbsp; Provide a name for the composite component (eg. "TableWithCopyPaste").</li><li>In the Resources Tree, under "Composites", your new widget should now be listed.</li></ol><p></p><h3><a id="TouseacompositeComponent">To use a composite Component</a><br></h3><p></p><ol><li>Build a new system in the normal way.</li><li>Select a composite component in the Resources Tree, and paste to the system in the normal way.&nbsp;</li></ol><p></p><p>The composite component will be listed in the Design Tree, but without its constituent components - only the enclosing element will be shown. The composite component has two non-editable properties to note:</p><p></p><ul><li>&nbsp; "CompositeType", which shows the name with which the composite was originally created.</li><li>&nbsp; "SourceString", which contains the definition of the sub-elements within the composite, for system use.</li></ul><p></p><h3><a id="ToeditacompositeComponent">To edit a composite Component</a><br></h3><p></p><ol><li>Clear the system.</li><li>Select the composite resource in the Resource Tree, and press "Load". This will load the composite as a system in design mode.</li><li>When your update is completed, save the composite again using System&gt;Encapsulate on the main menu.</li></ol><p></p><p>NOTE: This will not update any instantiated copies of your composite.&nbsp; To update instantiated copies, load the system(s) containing them, then delete and re-paste the composite.</p><h3><a id="TopassdataintoacompositeComponent">To pass data into a composite Component</a><br></h3><p>By default, events within a composite element have no view of the containing system, and so cannot obtain data from it. So while building a composite component, you can include a Composite Interface element (TXCompositeIntf in the Resources Tree, under Non-Visual components).</p><p></p><ol><li>Paste a composite interface element under the UIRootNode in the design tree.&nbsp;</li><li>In the object inspector Properties tab, press the "Add" button.&nbsp; This will create a new property for the interface.&nbsp;&nbsp;</li><li>On the popup screen, enter the property name.</li><li>Use the "Type" selector to specify whether the property is "Input" or "Output". Select "Input".</li><li>Enter some brief text to explain to a user of your composite what the purpose of this property is.</li><li>Press "Done".</li></ol><p></p><p>The new property is now listed in the properties list for the interface, and can be accessed from event code within the composite. Encapsulate the composite component, and then paste it into a test system. Note that the object inspector for the instantiated composite component has a tab page "Interface", in which your interface property is listed. An input property is editable here, or can be populated programmatically at run time.</p><h3><a id="TogetdataoutofacompositeComponent">To get data out of a composite Component</a><br></h3><p>Events in the enclosing system have no view of the sub-elements within a composite, and so cannot obtain property values directly.&nbsp; For this purpose an "output" property is needed. As in the section above, while editing the composite component, add an interface property, and set its type to "Output". When your composite is pasted into a containing system, the output property is listed in the Interface tab, but cannot be&nbsp; edited there.&nbsp; It is the responsibility of events within the composite to set the property value.&nbsp;&nbsp;</p><h3><a id="ToaddacallablemethodtoacompositeComponent">To add a callable method to a composite Component</a><br></h3><p>While editing your composite system in design mode, select your interface component (TXCompositeIntf) in the design tree.</p><p></p><ol><li>On the "Events" tab, press "Add" to create a new method.</li><li>On the popup screen, enter the name of the method, and its type (select "Read-Only").</li><li>Enter some brief text to explain to a user of your composite what the purpose of this method is.</li><li>Press "Done".</li></ol><p></p><p>The new method is now listed in the events list for the interface. Encapsulate the composite component, and then paste it into a test system. Note that the object inspector for the instantiated composite component has your method listed under "Events", but cannot be edited here. The enclosing system can execute the method using the "DoEvent" built-in.</p><h3><a id="ToaddaneditableEventHandlertoaCompositeComponent">To add an editable Event Handler to a Composite Component</a><br></h3><p>While editing your composite system in design mode, select your interface component (TXCompositeIntf) in the design tree.</p><p></p><ol><li>On the "Events" tab, press "Add" to create a new method.</li><li>On the popup screen, enter the name of the method, and its type (select "Editable").</li><li>Enter some brief text to explain to a user of your composite what event within the composite will execute it.</li><li>Press "Done".</li></ol><p></p><p>The new event handler is now listed in the events list for the interface, but code cannot be added here. The composite system can execute the method using the "DoEvent" built-in, for example on closing a form, or on changing a data table. Encapsulate the composite component, and then paste it into a test system. Note that the object inspector for the instantiated composite component has your event handler listed under "Events", and can be edited here, so that the user of the composite component can create their own handler.</p><p><br></p><hr id="null"><h2></h2><h2><a id="TheXIDEGPUJSWrapper">The XIDE GPUJS Wrapper</a><br></h2><p>The Pascal code for the GPU is accessed as a property of a GPU Canvas component which has been dropped onto the User Interface layout screen and/or as a node on the Code designer tree.&nbsp; The Pascal GPU code editor follows the same edit/compile cycle as for user code in the rest of the system. The differences are that this is code for blocks of threads in parallel. The code describes a single instruction multiple data (SIMD) approach where all the threads run the same code with thread specific code referencing "this.thread.x" , "this.thread.y" and "this.thread.z" to reflect their position in the block of threads. Parameter names are declared using a Paramlist property of the GPU canvas component and their transfer and run time execution is controlled by system calls described below. (N.B. parameters need to be passed as arrays so even scalar parameters passed into the code need to be referenced as follows "myParam[0]" )<br></p><p>The Pascal GPU code can daisy chain kernels. (Set the TXGPUCanvas property NumKernels&gt;0) For each kernel in the chain its return value must be set to "MyValue". The next kernel in the chain can then read all the thread return values from the previous kernel by reading from "MyArray".The initial "MyArray" passed to the first kernel in the chain is set as a property ("InitStageData") of the GPU canvas and can have any x,y,z sizes as chosen by the user. The final&nbsp; &nbsp;kernel is the graphics display kernel where you set the r,g,b values as usual. The calculated data input to the graphics display kernel can also be accessed using either the "GetGPUStageArray" or "GetGPUStageArrayAsString" instructions;</p><h2><a id="MathsfunctionsavailableintheGPU">Maths functions available in the GPU&nbsp;</a>&nbsp;code are as follows:-</h2><p></p><ul><li>abs(a) sign(a) trunc(a) ceil(a) max(a,b) min(a,b)</li><li>sin(a) cos(a) arcsin(a) arccos(a) arctan(a,b)</li><li>sqrt(a) power(a,b) ln(a) log10(a) log2(a)&nbsp;</li></ul><h2><a id="LimitationsofcodingfortheGPU">Limitations of coding for the GPU</a><br></h2><p>When coding in Pascal for the GPU, you should be aware that there are fundamental limitations on the constructs available. In particular:-</p><p></p><ul><li>All parameters passed into the GPU&nbsp; are real arrays (scalar parameters are real arrays of length one)<br></li><li>You can read from but not write to any of these array parameters</li><li>You cannot declare a local array</li><li>Each thread returns a single real value</li><li>You cannot communicate with any other thread (except by synchronising the results in a new kernel)</li><li>You cannot use a Boolean type (use 0 or 1 instead)</li><li>You cannot use "var" parameters in a function call</li><li>All function parameters must be a simple type</li><li>Nested function declarations do not follow normal (Pascal) scope rules</li><li>Loops are unrolled so you MUST SET the "<span style="font-family: Verdana, Arial, sans-serif; font-size: 12px; white-space: nowrap;">MaxIterations"</span>&nbsp;parameter at a high enough value to reflect your algorithm''s requirements</li><li>The number of threads in each kernel are given by the KernelXDims, KernelYDims and Kernel ZDims properties of the GPU Canvas and these MUST BE SET either manually or programatically before activating the GPU.</li><li>The GPU is a Single Instruction Multiple Data machine so branching in a thread does not jump over the code in the path not taken,&nbsp; it idles in order to allow other threads to execute the code in that path if need be.&nbsp;</li><li>Debugging on the GPU is "primitive" the only way to do it when running on the hardware is to write out intermediate results&nbsp; to the thread output value for selected threads which you dedicate to providing diagnostic output.&nbsp;</li></ul><p><br></p><p><br></p><p></p>';



{ TXIDEHelpForm }

{$ifndef JScript}
procedure TXIDEHelpForm.FormCreate(Sender: TObject);
begin
  myNode:=DoXFormCreated(self);
  HelpFormRoot:=FindDataNodeById(myNode,'HelpFormVBox1','',true);

  HelpHTMLText.SourceText:=BaseHTML;

end;

procedure TXIDEHelpForm.FormActivate(Sender: TObject);
begin
end;

procedure TXIDEHelpForm.FormResize(Sender: TObject);
begin
  DoFormResize(self, HelpFormVBox1);
end;

procedure TXIDEHelpForm.FormShow(Sender: TObject);
begin
  HelpHTMLText.SourceText:=HelpHTMLText.SourceText;
end;
{$endif}


procedure TXIDEHelpForm.InitialiseonShow;
begin
  self.Top:=100;
  self.Left:=150;
  {$ifdef JScript}
  // reset overview text AFTER the popup is rendered, otherwise actual height and width return 0
  asm
    var ob=this.HelpHTMLText;
    setTimeout(function(){pas.XHTMLText.ResetHTMLText(ob.NodeName,ob.NameSpace); }, 200);
  end;
  {$endif}
end;

end.

